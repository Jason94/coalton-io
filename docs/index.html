<!DOCTYPE html>
<html lang=en>
 <head>
  <meta charset=UTF-8>
  <title>API Documentation</title>
  <style>:root{
  --gap:28px;
  --content-gap:20px;
  --main-width:1100px;
  --bg:#ffffff;
  --fg:#1f1f1f;
  --muted:#6c6c6c;
  --border:#eeeeee;
  --code-bg:#f5f5f5;
  --code-block-bg:#1c1d21;
  --radius:8px
}
*,:before,:after{box-sizing:border-box}
html{overflow-y:scroll}
body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif;
  font-size:18px;
  line-height:1.65;
  background:var(--bg);
  color:var(--fg)
}
a{color:inherit;text-decoration:none}
a:hover{text-decoration:underline}
.main{
  position:relative;
  min-height:100vh;
  max-width:calc(var(--main-width) + var(--gap) * 2);
  margin:auto;
  padding:var(--gap)
}
.post-two-pane{width:100%}
.post-two-pane .post-content{
  display:flex;
  gap:var(--gap);
  align-items:flex-start
}
.sidebar{
  width:320px;
  position:sticky;
  top:10px;
  max-height:calc(100vh - 20px);
  overflow:auto;
  display:flex;
  flex-direction:column;
  padding-right:12px
}
.sidebar-header{
  flex-shrink:0;
  border-bottom:1px solid var(--border);
  padding:0 0 12px 0
}
.sidebar-content{padding:12px 0 0 0}
.sidebar ul{list-style:none;margin:0;padding:0}
.sidebar li{margin:0 0 6px 0}
.main-content{flex:1;min-width:0}
.main-content > h1{margin-top:0}
h1{margin:40px 0 32px;font-size:40px;line-height:1.15}
h3{margin:32px 0 16px;font-size:24px;line-height:1.2}
h4{margin:24px 0 10px;font-size:18pt;line-height:1.2}
p{margin:0 0 16px 0}
hr{margin: 30px 0;height: 2px;background: rgb(214, 214, 214);border: 0;}
code{
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  margin:0 4px;
  padding:4px 6px;
  font-size:.78em;
  line-height:1.5;
  background:var(--code-bg);
  border-radius:2px
}
.package-docstring,.docstring{white-space:pre-wrap}
pre{margin:16px 0}
pre code{
  display:block;
  margin:0;
  padding:10px;
  background:var(--code-block-bg);
  color:#d5d5d6;
  border-radius:var(--radius);
  overflow:auto;
  font-size:.85em
}
details{margin:12px 0 16px;border:0;padding:0}
summary{cursor:pointer;font-weight:600;padding:6px 0}
.methods-item{margin-top:5px}
.instances-list{margin:8px 0 12px 20px}
.instances-item{margin:4px 0}
.constructors-list{margin:8px 0 12px 20px}
.constructors-list li{margin:4px 0}
.symbol-search{margin-top:10px;position:relative}
.symbol-search input{
  width:100%;
  padding:8px;
  border:1px solid #ddd;
  border-radius:4px;
  font-size:.9rem
}
.search-results{
  display:none;
  position:absolute;
  left:0;
  right:0;
  top:calc(100% + 6px);
  background:var(--bg);
  border:1px solid #ddd;
  border-radius:4px;
  max-height:320px;
  overflow:auto;
  z-index:1000
}
.search-results.active{display:block}
.search-result-item{padding:10px;border-bottom:1px solid var(--border);cursor:pointer;font-size:.85rem}
.search-result-item:last-child{border-bottom:0}
.search-result-item:hover,.search-result-item.active{background:#f8f9fa}
.search-result-symbol{font-weight:700}
.search-result-type{color:#666;font-size:.8rem;margin-left:8px}
.search-result-package{color:#888;font-size:.8rem;margin-top:4px}
@media (max-width:1050px){
  .sidebar{display:none}
  .post-two-pane .post-content{display:block}
  .main{max-width:calc(820px + var(--gap) * 2)}
}</style>
 </head>
 <body>
  <main class=main>
   <article class=post-two-pane>
    <div class=post-content><aside class=sidebar>
      <div class=sidebar-header>
       <h3 id=reference>Reference</h3>
       <div class=symbol-search>
        <input type=text id=symbol-search-input
               placeholder="Search symbols."
               autocomplete=off>
        <div class=search-results id=search-results></div></div></div>
      <div class=sidebar-content>
       <ul>
        <li><a href="#io/thread-exceptions-package"><code>IO/THREAD-EXCEPTIONS</code></a>
        <li><a href="#io/exception-package"><code>IO/EXCEPTION</code></a>
        <li><a href="#io/monad-io-package"><code>IO/MONAD-IO</code></a>
        <li><a href="#io/simple-io-package"><code>IO/SIMPLE-IO</code></a>
        <li><a href="#io/resource-package"><code>IO/RESOURCE</code></a>
        <li><a href="#io/mut-package"><code>IO/MUT</code></a>
        <li><a href="#io/term-package"><code>IO/TERM</code></a>
        <li><a href="#io/random-package"><code>IO/RANDOM</code></a>
        <li><a href="#io/thread-package"><code>IO/THREAD</code></a>
        <li><a href="#io/file-package"><code>IO/FILE</code></a>
        <li><a href="#io/unique-package"><code>IO/UNIQUE</code></a>
        <li><a href="#io/network-package"><code>IO/NETWORK</code></a>
        <li><a href="#io/conc/parking-package"><code>IO/CONC/PARKING</code></a>
        <li><a href="#io/conc/scheduler-package"><code>IO/CONC/SCHEDULER</code></a>
        <li><a href="#io/conc/future-package"><code>IO/CONC/FUTURE</code></a>
        <li><a href="#io/conc/atomic-package"><code>IO/CONC/ATOMIC</code></a>
        <li><a href="#io/conc/mvar-package"><code>IO/CONC/MVAR</code></a>
        <li><a href="#io/conc/group-package"><code>IO/CONC/GROUP</code></a>
        <li><a href="#io/conc/stm-package"><code>IO/CONC/STM</code></a>
        <li><a href="#io/conc/mchan-scheduler-package"><code>IO/CONC/MCHAN-SCHEDULER</code></a>
        <li><a href="#io/conc/worker-pool-package"><code>IO/CONC/WORKER-POOL</code></a>
        <li><a href="#io/conc/ring-buffer-package"><code>IO/CONC/RING-BUFFER</code></a>
        <li><a href="#io/io-all-package"><code>IO/IO-ALL</code></a>
        <li><a href="#io/stubs/term-package"><code>IO/STUBS/TERM</code></a></ul></div></aside>
     <div class=main-content><h1 id="io/thread-exceptions-package">Package <code>IO/THREAD-EXCEPTIONS</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=synchronousthreadexception-type><a href="#synchronousthreadexception-type"><code>SynchronousThreadException</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L65-L69">src</a></sub></sup></sub></sup></h4><ul class=constructors-list>
        <li><code>(JoinedFailedThread <a href="#dynamic-type">Dynamic</a>)</code>
        <li><code>(TimeoutException <a href="#string-type">String</a>)</code></ul><p class=docstring>Exceptions that a thread raises whenever it encounters a threading
related problem. Unlike ThreadingException, these are actual exceptions.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#synchronousthreadexception-type">SynchronousThreadException</a></code>
         <li class=instances-item><code><a href="#signalable-class">Signalable</a> <a href="#synchronousthreadexception-type">SynchronousThreadException</a></code></ul></details><h4 id=threadingexception-type><a href="#threadingexception-type"><code>ThreadingException</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L33-L36">src</a></sub></sup></sub></sup></h4><ul class=constructors-list>
        <li><code>(InterruptCurrentThread <a href="#string-type">String</a>)</code></ul><p class=docstring>Thread exception sent asynchronously between threads.
This type isn&#39;t really an exception, it&#39;s more of a message.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#threadingexception-type">ThreadingException</a></code>
         <li class=instances-item><code><a href="#signalable-class">Signalable</a> <a href="#threadingexception-type">ThreadingException</a></code></ul></details><h4 id=unmaskfinallymode-type><a href="#unmaskfinallymode-type"><code>UnmaskFinallyMode</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L82-L90">src</a></sub></sup></sub></sup></h4><ul class=constructors-list>
        <li><code>Stopped</code>
        <li><code>Running</code></ul><p class=docstring>When a thread unmasks and calls a cleanup operation, the
thread is either:

* Still running, and will cleanup and continue
* Received a stop while it was masked, and will cleanup and then
  terminate itself.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code>
         <li class=instances-item><code><a href="#into-class">Into</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> <a href="#string-type">String</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=dynamic-is-threading-exception?-value><a href="#dynamic-is-threading-exception?-value"><code>(DYNAMIC-IS-THREADING-EXCEPTION? DYN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L43-L53">src</a></sub></sup></sub></sup></h4><code>(<a href="#dynamic-type">Dynamic</a> &rarr; <a href="#boolean-type">Boolean</a>)</code><p class=docstring>Returns true if the dynamic val is a threading exception or an
IoError containing a ThreadingException.</p><h4 id=is-threading-exception-value><a href="#is-threading-exception-value"><code>(IS-THREADING-EXCEPTION IO-ERR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L56-L63">src</a></sub></sup></sub></sup></h4><code>(<a href="#ioerror-type">IoError</a> &rarr; <a href="#boolean-type">Boolean</a>)</code><p class=docstring>Return True if IO-ERR contains a threading exception.</p></div>
      <hr><h1 id="io/exception-package">Package <code>IO/EXCEPTION</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadexception-class><a href="#monadexception-class"><code>MonadException</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L52-L76">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadexception-class">MonadException</a> :A</code><p class=docstring>A Monad that can raise and handle exceptions. IMPORTANT: Any MonadException
must catch and wrap all unhandled errors inside a wrap-io call.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>RAISE :: (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (:B :C))</code><span><br>Raise an exception.</span>
        <li class=methods-item><code>RAISE-DYNAMIC :: (<a href="#dynamic-type">Dynamic</a> &rarr; (:A :B))</code><span><br>Raise an exception wrapped in a Dynamic. Mainly useful to hand-off eexceptions&#xA;between IO instances.</span>
        <li class=methods-item><code>RERAISE :: ((:A :B) &rarr; (<a href="#unit-type">Unit</a> &rarr; (:A :C)) &rarr; (:A :B))</code><span><br>Run an operation, run a catch operation if the first operation raised,&#xA;then re-raise the exception. If the catch operation raises, that exception will&#xA;be emitted instead of the original exception.</span>
        <li class=methods-item><code>HANDLE :: <a href="#runtimerepr-class">RuntimeRepr</a> :A &rArr; ((:B :C) &rarr; (:A &rarr; (:B :C)) &rarr; (:B :C))</code><span><br>Run an operation, immediately handling if it raised an exception&#xA;that matches :e.</span>
        <li class=methods-item><code>HANDLE-ALL :: ((:A :B) &rarr; (<a href="#unit-type">Unit</a> &rarr; (:A :B)) &rarr; (:A :B))</code><span><br>Run an operation, immediately handling any exceptions raised.</span>
        <li class=methods-item><code>TRY-DYNAMIC :: ((:A :B) &rarr; (:A (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)))</code><span><br>Bring any unhandled exceptions into a Result wrapped in Dynamic.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code>(<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadio-class">MonadIo</a> :A) &rArr; <a href="#monadexception-class">MonadException</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> :A &rArr; <a href="#monadexception-class">MonadException</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> :A &rArr; <a href="#monadexception-class">MonadException</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=raise-result-dynamic-value><a href="#raise-result-dynamic-value"><code>(RAISE-RESULT-DYNAMIC OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L110-L115">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :A &rArr; ((:A (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)) &rarr; (:A :B))</code><h4 id=raise-result-value><a href="#raise-result-value"><code>(RAISE-RESULT IO-RES)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L99-L106">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadexception-class">MonadException</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) (<a href="#signalable-class">Signalable</a> :B) &rArr; ((:A (<a href="#result-type">Result</a> :B :C)) &rarr; (:A :C))</code><p class=docstring>Raise any (Err :e) into :m. Useful if (Err :e) represents any unhandleable, fatal
exception to the program.</p><h4 id=wrap-error_-value><a href="#wrap-error_-value"><code>(WRAP-ERROR_ THUNK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L119-L124">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :B &rArr; ((<a href="#unit-type">Unit</a> &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Run thunk, catching any unhandled Lisp/Coalton errors and raising
them as exceptions.</p><h4 id=try-all-value><a href="#try-all-value"><code>(TRY-ALL OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L89-L94">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :A &rArr; ((:A :B) &rarr; (:A (<a href="#optional-type">Optional</a> :B)))</code><p class=docstring>Bring the result of OP up into an Optional. Returns None if OP
raised any exceptions.</p><h4 id=try-value><a href="#try-value"><code>(TRY OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L80-L85">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadexception-class">MonadException</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :C) &rArr; ((:A :B) &rarr; (:A (<a href="#result-type">Result</a> :C :B)))</code><p class=docstring>Bring any unhandled exceptions of type :e up into a Result.
Continues to carry any unhandeld exceptions not of type :e.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-exception-do-handle-all-macro><a href="#io-classes-monad-exception-do-handle-all-macro"><code>DO-HANDLE-ALL (OP &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for handle-all.

Example:

(do-handle-all add-three-ints
  (modify (Cons 2))
  (pure 10))
===&gt;
(handle-all add-three-ints
  (const
    (do
     (modify (cons 2))
     (pure 10))))
</p><h4
    id=io-classes-monad-exception-do-handle-macro><a href="#io-classes-monad-exception-do-handle-macro"><code>DO-HANDLE (OP (ERR-SYM) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for handle.</p><h4
    id=io-classes-monad-exception-wrap-error-macro><a href="#io-classes-monad-exception-wrap-error-macro"><code>WRAP-ERROR (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run BODY, catching any unhandled Lisp/Coalton errors and raising
them as exceptions.</p><h4
    id=io-classes-monad-exception-do-reraise-macro><a href="#io-classes-monad-exception-do-reraise-macro"><code>DO-RERAISE (OP &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for reraise.</p></div>
      <hr><h1 id="io/monad-io-package">Package <code>IO/MONAD-IO</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=unliftio-class><a href="#unliftio-class"><code>UnliftIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L78-L79">src</a></sub></sup></sub></sup></h4><code>(<a href="#monadio-class">MonadIo</a> :A) (<a href="#liftio-class">LiftIo</a> :B :A) &rArr; <a href="#unliftio-class">UnliftIo</a> :A :B</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WITH-RUN-IN-IO :: ((((:A :B) &rarr; (:C :B)) &rarr; (:C :D)) &rarr; (:A :D))</code></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#unliftio-class">UnliftIo</a> <a href="#io-type">IO</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code>(<a href="#baseio-class">BaseIo</a> :A) (<a href="#unliftio-class">UnliftIo</a> :B :A) &rArr; <a href="#unliftio-class">UnliftIo</a> ((<a href="#envt-type">EnvT</a> :C) :B) :A</code></ul></details><h4 id=monadio-class><a href="#monadio-class"><code>MonadIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L58-L61">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadio-class">MonadIo</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WRAP-IO_ :: ((<a href="#unit-type">Unit</a> &rarr; :A) &rarr; (:B :A))</code><span><br>Wrap a (potentially) side-effectful function in the monad.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details><h4 id=baseio-class><a href="#baseio-class"><code>BaseIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L63-L73">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#baseio-class">BaseIo</a> :A</code><p class=docstring>A &#39;base&#39; IO implementation, which can be run to execute some
(potentially side-effectful) operation.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>RUN! :: ((:A :B) &rarr; :B)</code><span><br>Run a (potentially) side-effectful operation. Throws any unhandled&#xA;exceptions.</span>
        <li class=methods-item><code>RUN-HANDLED! :: ((:A :B) &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B))</code><span><br>Run a (potentially) side-effectful operation. Returns any unhandled&#xA;exceptions as an (Err e).</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> <a href="#io-type">IO</a></code></ul></details><h4 id=liftio-class><a href="#liftio-class"><code>LiftIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L75-L76">src</a></sub></sup></sub></sup></h4><code>(<a href="#monad-class">Monad</a> :A) (<a href="#baseio-class">BaseIo</a> :B) &rArr; <a href="#liftio-class">LiftIo</a> :B :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>LIFT-IO :: <a href="#baseio-class">BaseIo</a> :A &rArr; ((:A :B) &rarr; (:C :B))</code></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A (<a href="#loopt-type">LoopT</a> :B)</code>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A ((<a href="#envt-type">EnvT</a> :C) :B)</code>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A ((<a href="#statet-type">StateT</a> :C) :B)</code>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> :A &rArr; <a href="#liftio-class">LiftIo</a> :A :A</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=map-into-io-value><a href="#map-into-io-value"><code>(MAP-INTO-IO ITR A-&gt;RB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L188-L198">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#intoiterator-class">IntoIterator</a> :B :C) &rArr; (:B &rarr; (:C &rarr; (:D :E)) &rarr; (:F (<a href="#list-type">List</a> :E)))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator
and return the results. If you&#39;re having inference issues, try map-into-io_</p><h4 id=foreach-io-value><a href="#foreach-io-value"><code>(FOREACH-IO COLL A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L202-L222">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#intoiterator-class">IntoIterator</a> :B :C) &rArr; (:B &rarr; ((<a href="#cell-type">Cell</a> :C) &rarr; (:D :E)) &rarr; (:F <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
The next element of the iterator is passed into the operation via a cell.
If your effect can be run in simple-io/IO, the version in that package will be
faster!</p><h4 id=times-io-value><a href="#times-io-value"><code>(TIMES-IO N IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L225-L234">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#unliftio-class">UnliftIo</a> :B :A) (<a href="#liftto-class">LiftTo</a> :B :D) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:B :C) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform an IO operation N times. If the effect can be run in
simple-io/IO, the version in that package will be faster!</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-classes-monad-io-do-times-io-macro><a href="#io-classes-monad-io-do-times-io-macro"><code>DO-TIMES-IO (N &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform an IO operation N times. If the effect can be run in
simple-io/IO, the version in that package will be faster!</p><h4
    id=io-classes-monad-io-derive-lift-io-macro><a href="#io-classes-monad-io-derive-lift-io-macro"><code>DERIVE-LIFT-IO (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of LiftIo for a monad transformer.

Example:
  (derive-lift-io :m (e:EnvT :e :m))</p><h4
    id=io-classes-monad-io-do-foreach-io-macro><a href="#io-classes-monad-io-do-foreach-io-macro"><code>DO-FOREACH-IO ((VAR-SYM INTO-ITR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
VAR-SYM is bound to the value of the element in the iterator. If your effect can
be run in simple-io/IO, the version in that package will be faster!</p><h4
    id=io-classes-monad-io-derive-monad-io-macro><a href="#io-classes-monad-io-derive-monad-io-macro"><code>DERIVE-MONAD-IO (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIo for a monad transformer.

Example:
  (derive-monad-io :m (st:StateT :s :m))</p><h4 id=io-classes-monad-io-run-as!-macro><a href="#io-classes-monad-io-run-as!-macro"><code>RUN-AS! (M-TYPE M-OP)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run M-OP using the concrete RunIo M-TYPE. Useful for situations where
you want to create a generic MonadIo operation and immediately run it,
so the compiler can&#39;t infer the type of the actual monad you want to use.

Example:
  (run-as! (IO Unit) (pure Unit))

NOTE: Unfortunately, there seems to be a type inference bug that requires
putting in the full type of M-OP, not just (IO :a).
</p><h4 id=io-classes-monad-io-wrap-io-macro><a href="#io-classes-monad-io-wrap-io-macro"><code>WRAP-IO (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Wrap the execution of BODY in the IO monad.
Supports any MonadIo instance.

Example:
  (wrap-io
    (lisp :a (str)
      (cl:print str))</p><h4
    id=io-classes-monad-io-do-map-into-io-macro><a href="#io-classes-monad-io-do-map-into-io-macro"><code>DO-MAP-INTO-IO ((VAR LST) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/simple-io-package">Package <code>IO/SIMPLE-IO</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=io-type><a href="#io-type"><code>IO</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L83-L84">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#applicative-class">Applicative</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#functor-class">Functor</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadionetwork-class">MonadIoNetwork</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#io-type">IO</a> :A)</code>
         <li class=instances-item><code><a href="#unliftio-class">UnliftIo</a> <a href="#io-type">IO</a> <a href="#io-type">IO</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=raise-dynamic-io-value><a href="#raise-dynamic-io-value"><code>(RAISE-DYNAMIC-IO DYN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L219-L221">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#dynamic-type">Dynamic</a> &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=with-run-in-io_-value><a href="#with-run-in-io_-value"><code>(WITH-RUN-IN-IO_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L320-L323">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#unliftio-class">UnliftIo</a> :A <a href="#io-type">IO</a> &rArr; ((((:A :B) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:A :C))</code><p class=docstring>`with-run-in-io`, but pegged to the simple-io implementation. Useful when you
need to unlift, run, then immediately re-run a function. See, e.g., io-file:with-open-file%.</p><h4 id=try-dynamic-io-value><a href="#try-dynamic-io-value"><code>(TRY-DYNAMIC-IO IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L279-L294">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#io-type">IO</a> (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :A)))</code><h4 id=handle-all-io-value><a href="#handle-all-io-value"><code>(HANDLE-ALL-IO IO-OP HANDLE-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L263-L275">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (<a href="#io-type">IO</a> :A))</code><p class=docstring>Run IO-OP, and run HANDLE-OP to handle exceptions of any type thrown by IO-OP.</p><h4 id=map-into-io_-value><a href="#map-into-io_-value"><code>(MAP-INTO-IO_ ITR A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L345-L359">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :D) (<a href="#intoiterator-class">IntoIterator</a> :A :B) &rArr; (:A &rarr; (:B &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D (<a href="#list-type">List</a> :C)))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator
and return the results. More efficient than map-into-io, if you can run your
effect in a BaseIo.</p><h4 id=foreach-io_-value><a href="#foreach-io_-value"><code>(FOREACH-IO_ COLL A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L363-L381">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :D) (<a href="#intoiterator-class">IntoIterator</a> :A :B) &rArr; (:A &rarr; ((<a href="#cell-type">Cell</a> :B) &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
More efficient than foreach-io, if your effect can run in IO. The next element of the
iterator is passed into the operation via a cell.</p><h4 id=reraise-io-value><a href="#reraise-io-value"><code>(RERAISE-IO OP CATCH-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L229-L238">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=times-io_-value><a href="#times-io_-value"><code>(TIMES-IO_ N IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L384-L390">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :B &rArr; (<a href="#ufix-type">UFix</a> &rarr; (<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform an IO operation N times.</p><h4 id=raise-io_-value><a href="#raise-io_-value"><code>(RAISE-IO_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L225-L225">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (<a href="#io-type">IO</a> <a href="#unit-type">Unit</a>))</code><h4 id=handle-io-value><a href="#handle-io-value"><code>(HANDLE-IO IO-OP HANDLE-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L242-L259">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtimerepr-class">RuntimeRepr</a> :B &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=raise-io-value><a href="#raise-io-value"><code>(RAISE-IO E)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L213-L215">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (<a href="#io-type">IO</a> :B))</code><h4 id=run-io!-value><a href="#run-io!-value"><code>(RUN-IO! IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L147-L173">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; :A)</code><p class=docstring>Top-level run-io! that raises any unhandled exceptions. Also sets the current thread
as the global thread for structured concurrency, and exits any child threads on exit.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-io-impl-simple-io-do-map-into-io_-macro><a href="#io-io-impl-simple-io-do-map-into-io_-macro"><code>DO-MAP-INTO-IO_ ((VAR LST) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-simple-io-do-times-io_-macro><a href="#io-io-impl-simple-io-do-times-io_-macro"><code>DO-TIMES-IO_ (N &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform an IO operation N times.</p><h4
    id=io-io-impl-simple-io-do-foreach-io_-macro><a href="#io-io-impl-simple-io-do-foreach-io_-macro"><code>DO-FOREACH-IO_ ((VAR-SYM INTO-ITR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
More efficient than foreach-io, if your effect can run in IO. VAR-SYM is bound
to the value of the element in the iterator.</p></div>
      <hr><h1 id="io/resource-package">Package <code>IO/RESOURCE</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=exitcase-type><a href="#exitcase-type"><code>ExitCase</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L58-L61">src</a></sub></sup></sub></sup></h4><ul class=constructors-list>
        <li><code>Completed</code>
        <li><code>(Errored :A)</code></ul><p class=docstring>Signals the exit condition for an effectful computation using some resource.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> :A &rArr; <a href="#eq-class">Eq</a> (<a href="#exitcase-type">ExitCase</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#exitcase-type">ExitCase</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=bracket-io-masked_-value><a href="#bracket-io-masked_-value"><code>(BRACKET-IO-MASKED_ ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L154-L166">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) &rArr; ((:C :D) &rarr; (:D &rarr; (:C :E)) &rarr; (:D &rarr; (:C :F)) &rarr; (:C :F))</code><p class=docstring>Acquire a resource, run a computation with it, and release it. Guarantees that RELEASE-OP will
run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception, it will be re-raised after the
resource cleans up. If ACQUIRE-OP or RELEASE-OP raise an exception, then release is not guaranteed.
Masks the thread during the entire operation, including the computation.</p><h4 id=bracket-io-masked-value><a href="#bracket-io-masked-value"><code>(BRACKET-IO-MASKED ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L107-L124">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#runtimerepr-class">RuntimeRepr</a> :E) (<a href="#signalable-class">Signalable</a> :E) &rArr; ((:C :D) &rarr; (:D &rarr; (<a href="#exitcase-type">ExitCase</a> :E) &rarr; (:C :F)) &rarr; (:D &rarr; (:C :G)) &rarr; (:C :G))</code><p class=docstring>WARNING: BRACKET-IO-MASKED will *only* cleanup if the raised exception matches :e, or if the
computation succeedes. To guarantee cleanup after any exception, use BRACKET-IO-MASKED_

Acquire a resource, run a computation with it, and release it. Guarantees that RELEASE-OP will run
if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception, it will be re-raised after the
resource cleans up. If ACQUIRE-OP or RELEASE-OP raise an exception, then release is not guaranteed.
Masks the thread during the entire operation, including the computation.</p><h4 id=bracket-io_-value><a href="#bracket-io_-value"><code>(BRACKET-IO_ ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L131-L147">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) &rArr; ((:C :D) &rarr; (:D &rarr; (:C :E)) &rarr; (:D &rarr; (:C :F)) &rarr; (:C :F))</code><p class=docstring>Acquire a resource, run a computation with it, and release it. Guarantees that
RELEASE-OP will run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception,
it will be re-raised after the resource cleans up. If ACQUIRE-OP or RELEASE-OP raise
an exception, then release is not guaranteed.

Masks the thread during resource acquisition and release. The computation is not
masked, but if another thread stops this one during the computation then the resource
will release before the thread is stopped.</p><h4 id=bracket-io-value><a href="#bracket-io-value"><code>(BRACKET-IO ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L76-L100">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#runtimerepr-class">RuntimeRepr</a> :E) (<a href="#signalable-class">Signalable</a> :E) &rArr; ((:C :D) &rarr; (:D &rarr; (<a href="#exitcase-type">ExitCase</a> :E) &rarr; (:C :F)) &rarr; (:D &rarr; (:C :G)) &rarr; (:C :G))</code><p class=docstring>WARNING: BRACKET-IO will *only* cleanup if the raised exception matches :e,
or if the computation succeedes. To guarantee cleanup after any exception,
use BRACKET-IO_

Acquire a resource, run a computation with it, and release it. Guarantees that
RELEASE-OP will run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception,
it will be re-raised after the resource cleans up. If ACQUIRE-OP or RELEASE-OP raise
an exception, then release is not guaranteed.

Concurrent:
- Masks the thread during resource acquisition and release.
- The computation is not masked, and if another thread stops this one during the
  computation then the resource the resource will not be released.</p><h4 id=with-mask-value><a href="#with-mask-value"><code>(WITH-MASK OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L33-L44">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; ((:C :D) &rarr; (:C :D))</code><p class=docstring>Mask the current thread while running OP, automatically unmasking
afterward.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-resource-do-with-mask-macro><a href="#io-resource-do-with-mask-macro"><code>DO-WITH-MASK (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Evaluate BODY with the current thread masked, automatically unmasking
afterward.</p></div>
      <hr><h1 id="io/mut-package">Package <code>IO/MUT</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=var-type><a href="#var-type"><code>Var</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-var.lisp#L33-L34">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> (<a href="#cell-type">Cell</a> :A) &rArr; <a href="#eq-class">Eq</a> (<a href="#var-type">Var</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#var-type">Var</a> :A)</code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiovar-class><a href="#monadiovar-class"><code>MonadIoVar</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-var.lisp#L36-L48">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>NEW-VAR :: (:A &rarr; (:B (<a href="#var-type">Var</a> :A)))</code><span><br>Create a new variable with an initial value.</span>
        <li class=methods-item><code>READ :: ((<a href="#var-type">Var</a> :A) &rarr; (:B :A))</code><span><br>Read the current value stored in a variable.</span>
        <li class=methods-item><code>WRITE :: ((<a href="#var-type">Var</a> :A) &rarr; :A &rarr; (:B :A))</code><span><br>Set the value in a variable and return the old value.</span>
        <li class=methods-item><code>MODIFY :: ((<a href="#var-type">Var</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><span><br>Modify the value in a variable by applying F, and return the old value.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-var-derive-monad-var-macro><a href="#io-classes-monad-io-var-derive-monad-var-macro"><code>DERIVE-MONAD-VAR (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoVar for a monad transformer.

Example:
  (derive-monad-var :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-mut-implement-monad-io-var-macro><a href="#io-gen-impl-mut-implement-monad-io-var-macro"><code>IMPLEMENT-MONAD-IO-VAR (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/term-package">Package <code>IO/TERM</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadioterm-class><a href="#monadioterm-class"><code>MonadIoTerm</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-term.lisp#L24-L33">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WRITE :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><span><br>Write a string to standard output.</span>
        <li class=methods-item><code>WRITE-LINE :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><span><br>Write a string to standard output followed by a newline.</span>
        <li class=methods-item><code>READ-LINE :: (:A <a href="#string-type">String</a>)</code><span><br>Read a line from standard input.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-term-derive-monad-io-term-macro><a href="#io-classes-monad-io-term-derive-monad-io-term-macro"><code>DERIVE-MONAD-IO-TERM (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoTerm for a monad transformer.

Example:
  (derive-monad-io-term :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-term-implement-monad-io-term-macro><a href="#io-gen-impl-term-implement-monad-io-term-macro"><code>IMPLEMENT-MONAD-IO-TERM (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/random-package">Package <code>IO/RANDOM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=randomstate-type><a href="#randomstate-type"><code>RandomState</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L45-L45">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#randomstate-type">RandomState</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiorandom-class><a href="#monadiorandom-class"><code>MonadIoRandom</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L47-L65">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>MAKE-RANDOM-STATE :: (:A <a href="#randomstate-type">RandomState</a>)</code><span><br>Create a fresh random state.</span>
        <li class=methods-item><code>COPY-RANDOM-STATE :: (<a href="#randomstate-type">RandomState</a> &rarr; (:A <a href="#randomstate-type">RandomState</a>))</code><span><br>Create a copy of another random state, starting at the same seed.</span>
        <li class=methods-item><code>GET-CURRENT-RANDOM-STATE :: (:A <a href="#randomstate-type">RandomState</a>)</code><span><br>Get the current thread&apos;s random state.</span>
        <li class=methods-item><code>SET-CURRENT-RANDOM-STATE :: (<a href="#randomstate-type">RandomState</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Set the current thread&apos;s random state.</span>
        <li class=methods-item><code>RANDOM :: <a href="#randomlimit-class">RandomLimit</a> :A &rArr; (<a href="#randomstate-type">RandomState</a> &rarr; :A &rarr; (:B :A))</code><span><br>Generate a random value less than LIMIT using the given random state.</span>
        <li class=methods-item><code>RANDOM_ :: <a href="#randomlimit-class">RandomLimit</a> :A &rArr; (:A &rarr; (:B :A))</code><span><br>Generate a random value less than LIMIT using the current random state.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details><h4 id=randomlimit-class><a href="#randomlimit-class"><code>RandomLimit</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L36-L37">src</a></sub></sup></sub></sup></h4><code><a href="#num-class">Num</a> :A &rArr; <a href="#randomlimit-class">RandomLimit</a> :A</code><p class=docstring>A number that can be used to bound a random number value.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#f64-type">F64</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#f32-type">F32</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#integer-type">Integer</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#ufix-type">UFix</a></code></ul></details></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-random-derive-monad-io-random-macro><a href="#io-classes-monad-io-random-derive-monad-io-random-macro"><code>DERIVE-MONAD-IO-RANDOM (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoRandom for a monad transformer.

Example:
  (derive-monad-io-random :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-random-implement-monad-io-random-macro><a href="#io-gen-impl-random-implement-monad-io-random-macro"><code>IMPLEMENT-MONAD-IO-RANDOM (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/thread-package">Package <code>IO/THREAD</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=unhandledexceptionstrategy-type><a href="#unhandledexceptionstrategy-type"><code>UnhandledExceptionStrategy</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L118-L127">src</a></sub></sup></sub></sup></h4><p class=docstring>Controls what happens when a forked thread raises an exception that is not a
ThreadingException.

  - ThrowException: Immediately throws the Dynamic value in the child thread.
  - LogAndSwallow:  Logs the exception to *ERROR-OUTPUT* and ignore it until/if joined.
  - Swallow:        Ignore the error until/if joined.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#unhandledexceptionstrategy-type">UnhandledExceptionStrategy</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unhandledexceptionstrategy-type">UnhandledExceptionStrategy</a></code></ul></details><h4 id=timeoutstrategy-type><a href="#timeoutstrategy-type"><code>TimeoutStrategy</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L111-L114">src</a></sub></sup></sub></sup></h4><p class=docstring>Controls whether blocking IO operations use a timeout in milliseconds.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#f64-type">F64</a> &rArr; <a href="#eq-class">Eq</a> <a href="#timeoutstrategy-type">TimeoutStrategy</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#timeoutstrategy-type">TimeoutStrategy</a></code></ul></details><h4 id=generation-type><a href="#generation-type"><code>Generation</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L107-L108">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#u64-type">U64</a> &rArr; <a href="#eq-class">Eq</a> <a href="#generation-type">Generation</a></code>
         <li class=instances-item><code><a href="#ord-class">Ord</a> <a href="#generation-type">Generation</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#generation-type">Generation</a></code></ul></details><h4 id=forkscope-type><a href="#forkscope-type"><code>ForkScope</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L129-L137">src</a></sub></sup></sub></sup></h4><p class=docstring>Controls whether a forked thread is attached to a scope, and if so which one.

  - Structured:   Attach to the current thread&#39;s scope.
  - StructuredIn: Attach to the provided thread handle&#39;s scope.
  - Detached:     Attach to the global scope; the thread will end with the toplevel run!.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#forkscope-type">ForkScope</a> :A)</code></ul></details><h4 id=unmaskfinallymode-type><a href="#unmaskfinallymode-type"><code>UnmaskFinallyMode</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L82-L90">src</a></sub></sup></sub></sup></h4><p class=docstring>When a thread unmasks and calls a cleanup operation, the
thread is either:

* Still running, and will cleanup and continue
* Received a stop while it was masked, and will cleanup and then
  terminate itself.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code>
         <li class=instances-item><code><a href="#into-class">Into</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> <a href="#string-type">String</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code></ul></details></div>
      <hr><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=forkstrategy-type><a href="#forkstrategy-type"><code>ForkStrategy :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L139-L142">src</a></sub></sup></sub></sup></h4><p class=docstring>Strategy object controlling fork behavior (exception semantics + structured concurrency).</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#forkstrategy-type">ForkStrategy</a> :A)</code></ul></details><h4 id=iothread-type><a href="#iothread-type"><code>IoThread</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-impl/runtime.lisp#L157-L173">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> <a href="#iothread-type">IoThread</a> <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#iothread-type">IoThread</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#runtime-class">Runtime</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#iothread-type">IoThread</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiothread-class><a href="#monadiothread-class"><code>MonadIoThread</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L307-L313">src</a></sub></sup></sub></sup></h4><code>(<a href="#monadio-class">MonadIo</a> :A) (<a href="#runtime-class">Runtime</a> :B :C) &rArr; <a href="#monadiothread-class">MonadIoThread</a> :B :C :A</code><p class=docstring>A MonadIo which can spawn :t&#39;s. Other :t&#39;s error
separately. A spawned :t erroring will not cause the parent
:t to fail. :t can be any &#39;thread-like&#39; object, depending on the
underlying implementation - system threads, software-managed green
threads, etc.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B (<a href="#loopt-type">LoopT</a> :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#envt-type">EnvT</a> :D) :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#statet-type">StateT</a> :D) :C)</code></ul></details><h4 id=concurrent-class><a href="#concurrent-class"><code>Concurrent</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L262-L295">src</a></sub></sup></sub></sup></h4><code><a href="#concurrent-class">Concurrent</a> :A :B</code><p class=docstring>A Concurrent has thread-like semantics. It can be stopped, masked, unmasked, and await-ed.
Concurrents don&#39;t have a uniform fork function, becasue they require different initialization
input.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>STOP :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Stop a Concurrent. If the Concurrent has already stopped, does nothing. If the Concurrent is&#xA;masked, this will pend a stop on the Concurrent. When/if the Concurrent becomes completely unmaksed,&#xA;it will stop iself. Regardless of whether the target Concurrent is masked, STOP does not block or&#xA;wait for the target to complete.</span>
        <li class=methods-item><code>AWAIT :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A :E))</code><span><br>Block the current thread until the target Concurrent is completed, and retrieve its value.&#xA;Re-raises if the target Concurrent raised an unhandled exception</span>
        <li class=methods-item><code>MASK :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Mask the Concurrent so it can&apos;t be stopped.</span>
        <li class=methods-item><code>UNMASK :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Unmask the Concurrent so it can be stopped. Unmask respects nested masks - if the&#xA;Concurrent has been masked N times, it can only be stopped after being unmasked N times. When the&#xA;Concurrent unmasks, if there are any pending stops, it will immediately stop itself.</span>
        <li class=methods-item><code>UNMASK-FINALLY :: (<a href="#unliftio-class">UnliftIo</a> :A :B) (<a href="#liftto-class">LiftTo</a> :A :C) (<a href="#monadiothread-class">MonadIoThread</a> :D :E :A) (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :D :E :C) &rArr; (:F &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:A :G)) &rarr; (:C <a href="#unit-type">Unit</a>))</code><span><br>Unmask the thread, run the provided action, and then honor any pending stop for that&#xA;thread after the action finishes.&#xA;&#xA;Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be&#xA;inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the&#xA;callback should leave any resources in a valid state. An example of a valid callback: closing a log&#xA;file if the thread is stopped, or closing the log file with a final message if the thread is&#xA;continuing.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code>(<a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A <a href="#unit-type">Unit</a>) (<a href="#list-type">List</a> <a href="#unit-type">Unit</a>)) (<a href="#scheduler-class">Scheduler</a> :B) &rArr; <a href="#concurrent-class">Concurrent</a> (((<a href="#workerpool-type">WorkerPool</a> :B) :C) :A) <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> :A :B &rArr; <a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B) (<a href="#list-type">List</a> :B)</code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#future-type">Future</a> :A) :A</code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> <a href="#iothread-type">IoThread</a> <a href="#unit-type">Unit</a></code></ul></details><h4 id=runtime-class><a href="#runtime-class"><code>Runtime</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L159-L248">src</a></sub></sup></sub></sup></h4><code><a href="#runtime-class">Runtime</a> :A :B</code><p class=docstring>This class doesn&#39;t represent data, but the type tells a Concurrent and
a MonadIoThread how to hook into the native threading implementations that
a runtime provides.  A runtime has a &#39;base&#39; concurrent, which is the underlying
thread/fiber/etc. that the runtime produces to run concurrently. All other
Concurrents are built by composing on the base concurrent somehow.

Runtime is a low-level type that operates inside the normal MonadIo layer.
It should not be used by normal application code. Its two main purposes are:
(1) to make MonadIoThread generic over the type of thread it forks, and
(2) to build low-level, efficient concurrency tools that are generic
over the underlying thread type.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>CURRENT-THREAD! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B)</code><span><br>Get a handle for the current thread.</span>
        <li class=methods-item><code>SLEEP! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Sleep the current thread for MSECS milliseconds.</span>
        <li class=methods-item><code>FORK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; (<a href="#forkstrategy-type">ForkStrategy</a> :B) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :C)) &rarr; :B)</code><span><br>Spawn a new thread, which starts running immediately.&#xA;Returns the handle to the thread.&#xA;&#xA;The ForkStrategy controls both:&#xA;  - how unhandled exceptions behave, and&#xA;  - whether the fork is structured (and which thread&apos;s scope owns it).</span>
        <li class=methods-item><code>JOIN! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> <a href="#unit-type">Unit</a>))</code><span><br>Block the current thread until the target thread is completed.&#xA;Does not a retrieve value. Raises an exception if the target thread&#xA;raised an unhandled exception, wrapping the target thread&apos;s raised&#xA;exception. JOIN! is the lowest level operation to block on another&#xA;thread&apos;s termination, and most code should use AWAIT instead.</span>
        <li class=methods-item><code>STOP! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Stop a :t. If the thread has already stopped, does nothing.&#xA;If the :t is masked, this will pend a stop on the :t. When/if&#xA;the :t becomes completely unmaksed, it will stop iself. Regardless&#xA;of whether the target :t is masked, STOP does not block or wait for&#xA;the target thread to complete.</span>
        <li class=methods-item><code>MASK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Mask the thread so it can&apos;t be stopped.</span>
        <li class=methods-item><code>UNMASK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Unmask the thread so it can be stopped. Unmask respects&#xA;nested masks - if the thread has been masked N times, it can only be&#xA;stopped after being unmasked N times. When the thread unmasks, if&#xA;there are any pending stops, it will immediately be stopped.</span>
        <li class=methods-item><code>UNMASK-FINALLY! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; :C) &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Unmask the thread, run the provided action, and then honor any pending stop for that&#xA;thread after the action finishes.&#xA;&#xA;Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be&#xA;inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the&#xA;callback should leave any resources in a valid state. An example of a valid callback: closing a log&#xA;file if the thread is stopped, or closing the log file with a final message if the thread is&#xA;continuing.</span>
        <li class=methods-item><code>PARK-CURRENT-THREAD-IF! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; (<a href="#generation-type">Generation</a> &rarr; <a href="#unit-type">Unit</a>) &rarr; (<a href="#unit-type">Unit</a> &rarr; <a href="#boolean-type">Boolean</a>) &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Parks the current thread if SHOULD-PARK? returns True. Will park the thread until&#xA;woken by an unpark from another thread. Upon an unpark, the thread will resume even if&#xA;SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should&#xA;park, *not* if it should resume.&#xA;&#xA;Concurrent:&#xA;  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked&#xA;    state.&#xA;  - Can briefly block while trying to park the thread, if contended.</span>
        <li class=methods-item><code>PARK-CURRENT-THREAD-IF-WITH! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; (<a href="#generation-type">Generation</a> &rarr; <a href="#unit-type">Unit</a>) &rarr; (<a href="#unit-type">Unit</a> &rarr; <a href="#boolean-type">Boolean</a>) &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Parks the current thread if SHOULD-PARK? returns True. Will park the thread until&#xA;woken by an unpark from another thread. Upon an unpark, the thread will resume even if&#xA;SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should&#xA;park, *not* if it should resume.&#xA;&#xA;Concurrent:&#xA;  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked&#xA;    state.&#xA;  - Can briefly block while trying to park the thread, if contended.</span>
        <li class=methods-item><code>UNPARK-THREAD! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; <a href="#generation-type">Generation</a> &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Unparks the thread if it is still waiting on the generation. Attempting to unpark&#xA;the thread with a stale generation has no effect. A generation will be stale if the thread&#xA;has unparked and re-parked since the initial park.&#xA;&#xA;Concurrent:&#xA;  - Can briefly block while trying to unpark the thread, if contended.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtime-class">Runtime</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=unmask-current-thread-finally-value><a href="#unmask-current-thread-finally-value"><code>(UNMASK-CURRENT-THREAD-FINALLY OP-FINALLY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L503-L520">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :E) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) &rArr; ((<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:D <a href="#unit-type">Unit</a>)) &rarr; (:E <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the current thread, run the provided action, and then honor any pending stop
for that thread after the action finishes.

Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback
could be inconsistent with whether the Concurrent is ultimately stopped. Regardless of the
input, the callback should leave any resources in a valid state.

An example of a valid callback: closing a log file if the thread is stopped, or closing
the log file with a final message if the thread is continuing.</p><h4 id=park-current-thread-if-with-value><a href="#park-current-thread-if-with-value"><code>(PARK-CURRENT-THREAD-IF-WITH WITH-GEN SHOULD-PARK? STRATEGY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L550-L565">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((<a href="#generation-type">Generation</a> &rarr; (:C <a href="#unit-type">Unit</a>)) &rarr; (:C <a href="#boolean-type">Boolean</a>) &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread if SHOULD-PARK? returns True. Will park the thread until
woken by an unpark from another thread. Upon an unpark, the thread will resume even if
SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=park-current-thread-if-value><a href="#park-current-thread-if-value"><code>(PARK-CURRENT-THREAD-IF WITH-GEN SHOULD-PARK?)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L528-L542">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((<a href="#generation-type">Generation</a> &rarr; (:C <a href="#unit-type">Unit</a>)) &rarr; (:C <a href="#boolean-type">Boolean</a>) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread if SHOULD-PARK? returns True. Will park the thread until
woken by an unpark from another thread. Upon an unpark, the thread will resume even if
SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=unmask-thread-finally-value><a href="#unmask-thread-finally-value"><code>(UNMASK-THREAD-FINALLY THREAD OP-FINALLY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L482-L496">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) &rArr; (:C &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:D :E)) &rarr; (:F <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the thread, run the provided action, and then honor any
 pending stop for that thread after the action finishes.

Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be
inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the
callback should leave any resources in a valid state. An example of a valid callback: closing a log
file if the thread is stopped, or closing the log file with a final message if the thread is
continuing.</p><h4 id=unmask-current-thread-value><a href="#unmask-current-thread-value"><code>UNMASK-CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L468-L477">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C <a href="#unit-type">Unit</a>)</code><p class=docstring>Unmask the current thread so it can be stopped. Unmask respects
nested masks - if the thread has been masked N times, it can only be
stopped after being unmasked N times.</p><h4 id=mask-current-thread-value><a href="#mask-current-thread-value"><code>MASK-CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L448-L456">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C <a href="#unit-type">Unit</a>)</code><p class=docstring>Mask the current thread so it can&#39;t be stopped.</p><h4 id=fork-thread-with-value><a href="#fork-thread-with-value"><code>(FORK-THREAD-WITH STRAT OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L378-L390">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) &rArr; ((<a href="#forkstrategy-type">ForkStrategy</a> :C) &rarr; (:D :E) &rarr; (:F :C))</code><p class=docstring>Spawn a new thread using STRAT.

This version can accept any underlying BaseIo, which can be useful, but
causes inference issues in some cases.</p><h4 id=unmask-current!-value><a href="#unmask-current!-value"><code>(UNMASK-CURRENT! RT-PRX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L258-L260">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtime-class">Runtime</a> :B :A &rArr; ((<a href="#proxy-type">Proxy</a> :B) &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Unmask the current thread.</p><h4 id=current-thread-value><a href="#current-thread-value"><code>CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L436-L438">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :C :B &rArr; (:B :C)</code><p class=docstring>Get the current thread.</p><h4 id=unpark-thread-value><a href="#unpark-thread-value"><code>(UNPARK-THREAD GEN THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L569-L576">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (<a href="#generation-type">Generation</a> &rarr; :B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Unparks the thread if it is still waiting on the generation. Attempting to unpark
the thread with a stale generation has no effect. A generation will be stale if the thread
has unparked and re-parked since the initial park.

Concurrent:
  - Can briefly block while trying to unpark the thread, if contended.</p><h4 id=unmask-thread-value><a href="#unmask-thread-value"><code>(UNMASK-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L460-L464">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the thread so it can be stopped. Unmask respects
nested masks - if the thread has been masked N times, it can only be
stopped after being unmasked N times.</p><h4 id=mask-current!-value><a href="#mask-current!-value"><code>(MASK-CURRENT! RT-PRX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L252-L254">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtime-class">Runtime</a> :B :A &rArr; ((<a href="#proxy-type">Proxy</a> :B) &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Mask the current thread.</p><h4 id=stop-thread-value><a href="#stop-thread-value"><code>(STOP-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L424-L426">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Stop a thread. If the thread has already stopped, does nothing.</p><h4 id=mask-thread-value><a href="#mask-thread-value"><code>(MASK-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L442-L444">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Mask the thread so it can&#39;t be stopped.</p><h4 id=join-thread-value><a href="#join-thread-value"><code>(JOIN-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L406-L420">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Block the current thread until the target thread is completed.
Does not a retrieve value. Raises an exception if the target thread
raised an unhandled exception, wrapping the target thread&#39;s raised
exception. JOIN-THREAD is the lowest level operation to block on another
thread&#39;s termination.</p><h4 id=fork-thread-value><a href="#fork-thread-value"><code>(FORK-THREAD OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L395-L402">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :C :A) (<a href="#liftto-class">LiftTo</a> :C :E) (<a href="#monadiothread-class">MonadIoThread</a> :B :F :C) &rArr; ((:C :D) &rarr; (:E :F))</code><p class=docstring>Spawn a new thread, which starts running immediately. Returns
the handle to the thread. If the thread raises an unhandled exception,
it will be logged to *ERROR-OUTPUT* and swallowed, until/if the thread
is joined.

This is the default fork behavior: structured + log-and-swallow.</p><h4 id=sleep-value><a href="#sleep-value"><code>(SLEEP MSEC)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L430-L432">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Sleep the current thread for MSECS milliseconds.</p><h4 id=write-line-sync-value><a href="#write-line-sync-value"><code>(WRITE-LINE-SYNC MSG)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-thread.lisp#L25-L28">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#into-class">Into</a> :A <a href="#string-type">String</a>) (<a href="#monadioterm-class">MonadIoTerm</a> :B) &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Perform a synchrozied write-line to the terminal. Not performant - mainly useful
for debugging.</p><h4 id=park-current-thread-if_-value><a href="#park-current-thread-if_-value"><code>(PARK-CURRENT-THREAD-IF_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L55-L65">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#monadio-class">MonadIo</a> :A &rArr; ((<a href="#generation-type">Generation</a> &rarr; (<a href="#io-type">IO</a> <a href="#unit-type">Unit</a>)) &rarr; (<a href="#io-type">IO</a> <a href="#boolean-type">Boolean</a>) &rarr; (:A <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread if SHOULD-PARK? returns True. Will park the thread until
woken by an unpark from another thread. Upon an unpark, the thread will resume even if
SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=unmask-thread-finally_-value><a href="#unmask-thread-finally_-value"><code>(UNMASK-THREAD-FINALLY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L44-L44">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) &rArr; (<a href="#iothread-type">IoThread</a> &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (:B <a href="#unit-type">Unit</a>))</code><h4 id=fork-thread-with_-value><a href="#fork-thread-with_-value"><code>(FORK-THREAD-WITH_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L38-L38">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#forkstrategy-type">ForkStrategy</a> <a href="#iothread-type">IoThread</a>) &rarr; (<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#iothread-type">IoThread</a>))</code><h4 id=unmask-finally_-value><a href="#unmask-finally_-value"><code>(UNMASK-FINALLY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L50-L50">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :D) (<a href="#monadexception-class">MonadException</a> :D) (<a href="#concurrent-class">Concurrent</a> :B :A) (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :D) &rArr; (:B &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D <a href="#unit-type">Unit</a>))</code><h4 id=fork-thread_-value><a href="#fork-thread_-value"><code>(FORK-THREAD_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L33-L33">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#iothread-type">IoThread</a>))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-thread-do-fork-thread-macro><a href="#io-classes-monad-io-thread-do-fork-thread-macro"><code>DO-FORK-THREAD (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-thread-do-fork-thread_-macro><a href="#io-io-impl-thread-do-fork-thread_-macro"><code>DO-FORK-THREAD_ (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-thread-derive-monad-io-thread-macro><a href="#io-classes-monad-io-thread-derive-monad-io-thread-macro"><code>DERIVE-MONAD-IO-THREAD (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoThread for a monad transformer.

Example:
  (derive-monad-io-thread :m (st:StateT :s :m))</p><h4
    id=io-io-impl-thread-do-fork-thread-with_-macro><a href="#io-io-impl-thread-do-fork-thread-with_-macro"><code>DO-FORK-THREAD-WITH_ (STRATEGY &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-thread-do-fork-thread-with-macro><a href="#io-classes-monad-io-thread-do-fork-thread-with-macro"><code>DO-FORK-THREAD-WITH (STRATEGY &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-gen-impl-thread-implement-monad-io-thread-macro><a href="#io-gen-impl-thread-implement-monad-io-thread-macro"><code>IMPLEMENT-MONAD-IO-THREAD (MONAD RUNTIME THREAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/file-package">Package <code>IO/FILE</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiofile-class><a href="#monadiofile-class"><code>MonadIoFile</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-file.lisp#L57-L137">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns whether a file or directory exists.</span>
        <li class=methods-item><code>FILE-EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns True if a pathname names a file that exists.</span>
        <li class=methods-item><code>DIRECTORY-EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns True if a pathname names a directory that exists.</span>
        <li class=methods-item><code>OPEN :: <a href="#file-class">File</a> :A &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#filestream-type">FileStream</a> :A))))</code>
        <li class=methods-item><code>CLOSE :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :C)))</code><span><br>Closes a FileStream.</span>
        <li class=methods-item><code>ABORT :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :C)))</code><span><br>Closes a FileStream and aborts all operations..</span>
        <li class=methods-item><code>CREATE-TEMP-DIRECTORY :: (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>))</code>
        <li class=methods-item><code>CREATE-TEMP-FILE :: (<a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code>
        <li class=methods-item><code>COPY :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#into-class">Into</a> :B <a href="#pathname-type">Pathname</a>) &rArr; (:A &rarr; :B &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Copies a file to a new location.</span>
        <li class=methods-item><code>CREATE-DIRECTORY :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code><span><br>This is equivalent to `mkdir -p`. Creates a directory and its parents. The pathname must be a valid directory pathname.</span>
        <li class=methods-item><code>DELETE-FILE :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Deletes a given file if the file exists.</span>
        <li class=methods-item><code>REMOVE-DIRECTORY :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :A)))</code><span><br>Deletes an empty directory.</span>
        <li class=methods-item><code>REMOVE-DIRECTORY-RECURSIVE :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Deletes a target directory recursively. Equivalent to `rm -r`. Errors if the path is not a directory.</span>
        <li class=methods-item><code>SYSTEM-RELATIVE-PATHNAME :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; <a href="#string-type">String</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code><span><br>Generates a system-relative-pathname for a given filename or path. This is a wrapper for `asdf:system-relative-pathname`. `Name` will likely be an empty string unless a subdirectory or filename is specified.</span>
        <li class=methods-item><code>READ-FILE-TO-STRING :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>)))</code><span><br>Reads a file into a string, given a pathname string.</span>
        <li class=methods-item><code>READ-FILE-LINES :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>))))</code><span><br>Reads a file into lines, given a pathname or string.</span>
        <li class=methods-item><code>READ-CHAR :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#char-type">Char</a>)))</code><span><br>Reads a character from an FileStream.</span>
        <li class=methods-item><code>READ-LINE :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>)))</code>
        <li class=methods-item><code>WRITE-CHAR :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#char-type">Char</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a `Char` to the stream.</span>
        <li class=methods-item><code>WRITE-LINE :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a string with an appended newline to a filestream of type Char.</span>
        <li class=methods-item><code>WRITE-STRING :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a `string` to a FileStream of type Char.</span>
        <li class=methods-item><code>READ-FILE-TO-VECTOR :: <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A))))</code><span><br>Reads a file into a vector of type `:a`.</span>
        <li class=methods-item><code>READ-VECTOR :: <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A))))</code><span><br>Reads a chunk of a file into a vector of type `:a`.</span>
        <li class=methods-item><code>WRITE-VECTOR :: (<a href="#file-class">File</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :A) &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#vector-type">Vector</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes elements of an vector of type `:a` to a stream of type `:a`.</span>
        <li class=methods-item><code>WRITE-TO-FILE :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#file-class">File</a> :B) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) &rArr; (:A &rarr; (<a href="#vector-type">Vector</a> :B) &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Opens and writes to a file with data of type :a. Supersedes existing data on the file.</span>
        <li class=methods-item><code>APPEND-TO-FILE :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#file-class">File</a> :B) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) &rArr; (:A &rarr; (<a href="#vector-type">Vector</a> :B) &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Opens and appends a file with data of type :a.</span>
        <li class=methods-item><code>SET-FILE-POSITION :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Sets the file position of a file stream.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=with-temp-directory-value><a href="#with-temp-directory-value"><code>(WITH-TEMP-DIRECTORY K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L249-L260">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; ((<a href="#pathname-type">Pathname</a> &rarr; (:D :E)) &rarr; (:F :E))</code><p class=docstring>Performs an operation `thunk` inside a temporary directory.
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-TEMP-DIRECTORY_ if you have issues.</p><h4 id=with-temp-file-value><a href="#with-temp-file-value"><code>(WITH-TEMP-FILE FILE-TYPE K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L230-L243">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#file-class">File</a> :D) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadexception-class">MonadException</a> :A) &rArr; (<a href="#string-type">String</a> &rarr; ((<a href="#filestream-type">FileStream</a> :D) &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Performs an operation `thunk` on a temporary file. File type extensions need to include `.`
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-TEMP-FILE_ if you have issues.</p><h4 id=with-open-file-value><a href="#with-open-file-value"><code>(WITH-OPEN-FILE OPTS K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L211-L223">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#file-class">File</a> :D) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; ((<a href="#filestream-type">FileStream</a> :D) &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Opens a file stream, performs K on it, then closes the stream.
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-OPEN-FILE_ if you have issues.</p><h4 id=with-temp-directory_-value><a href="#with-temp-directory_-value"><code>(WITH-TEMP-DIRECTORY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L43-L43">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#unliftio-class">UnliftIo</a> :B <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#pathname-type">Pathname</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (:B :A))</code><h4 id=with-temp-file_-value><a href="#with-temp-file_-value"><code>(WITH-TEMP-FILE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L38-L38">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#file-class">File</a> :A) (<a href="#unliftio-class">UnliftIo</a> :C <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code><h4 id=with-open-file_-value><a href="#with-open-file_-value"><code>(WITH-OPEN-FILE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L32-L32">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#file-class">File</a> :A) (<a href="#unliftio-class">UnliftIo</a> :C <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-file-do-with-temp-directory-macro><a href="#io-gen-impl-file-do-with-temp-directory-macro"><code>DO-WITH-TEMP-DIRECTORY ((DIR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-directory`.</p><h4
    id=io-io-impl-file-do-with-temp-directory_-macro><a href="#io-io-impl-file-do-with-temp-directory_-macro"><code>DO-WITH-TEMP-DIRECTORY_ ((DIR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-directory_`.</p><h4
    id=io-io-impl-file-do-with-open-file_-macro><a href="#io-io-impl-file-do-with-open-file_-macro"><code>DO-WITH-OPEN-FILE_ (OPTS (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-open-file_`. Expands to a continuation where BODY runs in `do`.

Usage:
  (do-with-open-file_ opts (fs)
    (line &lt;- (read-char fs))
    ...)
</p><h4
    id=io-classes-monad-io-file-derive-monad-io-file-macro><a href="#io-classes-monad-io-file-derive-monad-io-file-macro"><code>DERIVE-MONAD-IO-FILE (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Derive a `MonadIoFile` instance for MONADT-FORM by lifting into the base instance.

Example:
  (derive-monad-io-file :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-file-implement-monad-io-file-macro><a href="#io-gen-impl-file-implement-monad-io-file-macro"><code>IMPLEMENT-MONAD-IO-FILE (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-file-do-with-temp-file_-macro><a href="#io-io-impl-file-do-with-temp-file_-macro"><code>DO-WITH-TEMP-FILE_ (TYPE (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-file_` (TYPE is a string like &quot;txt&quot;).</p><h4
    id=io-gen-impl-file-do-with-temp-file-macro><a href="#io-gen-impl-file-do-with-temp-file-macro"><code>DO-WITH-TEMP-FILE (TYPE (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-file` (TYPE is a string like &quot;txt&quot;).</p><h4
    id=io-gen-impl-file-do-with-open-file-macro><a href="#io-gen-impl-file-do-with-open-file-macro"><code>DO-WITH-OPEN-FILE (OPTS (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-open-file`. Expands to a continuation where BODY runs in `do`.

Usage:
  (do-with-open-file opts (fs)
    (line &lt;- (read-char fs))
    ...)
</p></div>
      <hr><h1 id="io/unique-package">Package <code>IO/UNIQUE</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=unique-type><a href="#unique-type"><code>Unique</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L31-L32">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#integer-type">Integer</a> &rArr; <a href="#eq-class">Eq</a> <a href="#unique-type">Unique</a></code>
         <li class=instances-item><code><a href="#ord-class">Ord</a> <a href="#unique-type">Unique</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unique-type">Unique</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiounique-class><a href="#monadiounique-class"><code>MonadIoUnique</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L47-L52">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>NEW-UNIQUE :: (:A <a href="#unique-type">Unique</a>)</code><span><br>Generate a value that will be unique within this run of the program.&#xA;Threadsafe - calling from different threads will still result in unique&#xA;values across all threads.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=to-int-value><a href="#to-int-value"><code>(TO-INT (UNIQUE% I))</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L40-L45">src</a></sub></sup></sub></sup></h4><code>(<a href="#unique-type">Unique</a> &rarr; <a href="#integer-type">Integer</a>)</code><p class=docstring>Convert a unique value to an integer.

It is guaranteed that: (/= (to-int a) (to-int b))
for any two different Unique instances.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-unique-implement-monad-io-unique-macro><a href="#io-gen-impl-unique-implement-monad-io-unique-macro"><code>IMPLEMENT-MONAD-IO-UNIQUE (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-unique-derive-monad-io-unique-macro><a href="#io-classes-monad-io-unique-derive-monad-io-unique-macro"><code>DERIVE-MONAD-IO-UNIQUE (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoUnique for a monad transformer.

Example:
  (derive-monad-io-unique :m (st:StateT :s :m))</p></div>
      <hr><h1 id="io/network-package">Package <code>IO/NETWORK</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=byteconnectionsocket-type><a href="#byteconnectionsocket-type"><code>ByteConnectionSocket</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-network.lisp#L59-L60">src</a></sub></sup></sub></sup></h4><p class=docstring>A socket connecting a client and server using a byte stream.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#byteconnectionsocket-type">ByteConnectionSocket</a></code></ul></details><h4 id=connectionsocket-type><a href="#connectionsocket-type"><code>ConnectionSocket</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-network.lisp#L51-L52">src</a></sub></sup></sub></sup></h4><p class=docstring>A socket connecting a client and server.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#connectionsocket-type">ConnectionSocket</a></code></ul></details><h4 id=byteserversocket-type><a href="#byteserversocket-type"><code>ByteServerSocket</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-network.lisp#L55-L56">src</a></sub></sup></sub></sup></h4><p class=docstring>A server socket listening for new byte-stream connections.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#byteserversocket-type">ByteServerSocket</a></code></ul></details><h4 id=serversocket-type><a href="#serversocket-type"><code>ServerSocket</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-network.lisp#L47-L48">src</a></sub></sup></sub></sup></h4><p class=docstring>A server socket listening for new connections.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#serversocket-type">ServerSocket</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadionetwork-class><a href="#monadionetwork-class"><code>MonadIoNetwork</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-network.lisp#L62-L105">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadionetwork-class">MonadIoNetwork</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>SOCKET-LISTEN :: (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (:A <a href="#serversocket-type">ServerSocket</a>))</code><span><br>Start a new server socket, listening on HOSTNAME and PORT.</span>
        <li class=methods-item><code>SOCKET-ACCEPT :: (<a href="#serversocket-type">ServerSocket</a> &rarr; (:A <a href="#connectionsocket-type">ConnectionSocket</a>))</code><span><br>Accept a connection with a new client.</span>
        <li class=methods-item><code>SOCKET-CONNECT :: (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (:A <a href="#connectionsocket-type">ConnectionSocket</a>))</code><span><br>Connect to a server at HOSTNAME and PORT, returning a new connection.</span>
        <li class=methods-item><code>CLOSE-CONNECTION :: (<a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Close an open connection socket.</span>
        <li class=methods-item><code>CLOSE-SERVER :: (<a href="#serversocket-type">ServerSocket</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Close an open server socket.</span>
        <li class=methods-item><code>WRITE-LINE :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; <a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:B <a href="#unit-type">Unit</a>))</code>
        <li class=methods-item><code>READ-LINE :: (<a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:A <a href="#string-type">String</a>))</code><span><br>Read the next line from the socket. Blocks until data is sent!</span>
        <li class=methods-item><code>BYTE-SOCKET-LISTEN :: (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (:A <a href="#byteserversocket-type">ByteServerSocket</a>))</code><span><br>Start a new server socket for byte-stream connections, listening on HOSTNAME and PORT.</span>
        <li class=methods-item><code>BYTE-SOCKET-ACCEPT :: (<a href="#byteserversocket-type">ByteServerSocket</a> &rarr; (:A <a href="#byteconnectionsocket-type">ByteConnectionSocket</a>))</code><span><br>Accept a byte-stream connection with a new client.</span>
        <li class=methods-item><code>BYTE-SOCKET-CONNECT :: (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (:A <a href="#byteconnectionsocket-type">ByteConnectionSocket</a>))</code><span><br>Connect to a server at HOSTNAME and PORT using a byte stream, returning a new connection.</span>
        <li class=methods-item><code>CLOSE-BYTE-CONNECTION :: (<a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Close an open byte-stream connection socket.</span>
        <li class=methods-item><code>CLOSE-BYTE-SERVER :: (<a href="#byteserversocket-type">ByteServerSocket</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Close an open byte-stream server socket.</span>
        <li class=methods-item><code>WRITE-BYTES :: ((<a href="#vector-type">Vector</a> <a href="#u8-type">U8</a>) &rarr; <a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Write all bytes in the vector to the socket.</span>
        <li class=methods-item><code>READ-EXACTLY :: (<a href="#ufix-type">UFix</a> &rarr; <a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:A (<a href="#vector-type">Vector</a> <a href="#u8-type">U8</a>)))</code><span><br>Read exactly N bytes from the socket. Blocks until N bytes are available.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadionetwork-class">MonadIoNetwork</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadionetwork-class">MonadIoNetwork</a> :A &rArr; <a href="#monadionetwork-class">MonadIoNetwork</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadionetwork-class">MonadIoNetwork</a> :A &rArr; <a href="#monadionetwork-class">MonadIoNetwork</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadionetwork-class">MonadIoNetwork</a> :A &rArr; <a href="#monadionetwork-class">MonadIoNetwork</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=byte-socket-accept-fork-with-value><a href="#byte-socket-accept-fork-with-value"><code>(BYTE-SOCKET-ACCEPT-FORK-WITH SERVER-SOCKET OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L280-L289">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :B) (<a href="#monadiothread-class">MonadIoThread</a> :A :D :B) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#unliftio-class">UnliftIo</a> :B :B) &rArr; (<a href="#byteserversocket-type">ByteServerSocket</a> &rarr; (<a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:B :C)) &rarr; (:B :D))</code><p class=docstring>Accept a byte-stream connection with a new client and run operation OP on a new thread.
Guarantees that the socket will close on cleanup. Returns a handle to the forked thread.</p><h4 id=byte-socket-connect-with-value><a href="#byte-socket-connect-with-value"><code>(BYTE-SOCKET-CONNECT-WITH HOSTNAME PORT OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L255-L261">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Run operation OP with a byte-stream connection to an open server socket at HOSTNAME and PORT.
Guarantees that the socket will close on cleanup.</p><h4 id=socket-accept-fork-with-value><a href="#socket-accept-fork-with-value"><code>(SOCKET-ACCEPT-FORK-WITH SERVER-SOCKET OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L232-L241">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :B) (<a href="#monadiothread-class">MonadIoThread</a> :A :D :B) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#unliftio-class">UnliftIo</a> :B :B) &rArr; (<a href="#serversocket-type">ServerSocket</a> &rarr; (<a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:B :C)) &rarr; (:B :D))</code><p class=docstring>Accept a connection with a new client and run operation OP on a new thread.
Guarantees that the socket will close on cleanup. Returns a handle to the forked thread.</p><h4 id=byte-socket-listen-with-value><a href="#byte-socket-listen-with-value"><code>(BYTE-SOCKET-LISTEN-WITH HOSTNAME PORT OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L245-L251">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#byteserversocket-type">ByteServerSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Run operation OP with a new byte-stream server socket, listening on HOSTNAME and PORT.
Guarantees that the socket will close on cleanup.</p><h4 id=byte-socket-accept-with-value><a href="#byte-socket-accept-with-value"><code>(BYTE-SOCKET-ACCEPT-WITH SERVER-SOCKET OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L265-L275">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#byteserversocket-type">ByteServerSocket</a> &rarr; (<a href="#byteconnectionsocket-type">ByteConnectionSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Accept a byte-stream connection with a new client and run operation OP. Guarantees that the
socket will close on cleanup.

Note: If you fork a thread inside this, the operation on this thread will probably finish
and close the socket before you intend. For multithreaded uses, use
byte-socket-accept-fork-with.</p><h4 id=socket-connect-with-value><a href="#socket-connect-with-value"><code>(SOCKET-CONNECT-WITH HOSTNAME PORT OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L205-L211">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Run operation OP with a connection to an open server socket at HOSTNAME and PORT.
Guarantees that the socket will close on cleanup.</p><h4 id=socket-listen-with-value><a href="#socket-listen-with-value"><code>(SOCKET-LISTEN-WITH HOSTNAME PORT OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L193-L199">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#serversocket-type">ServerSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Run operation OP with a new server socket, listening on HOSTNAME and PORT. Guarantees
that the socket will close on cleanup.</p><h4 id=socket-accept-with-value><a href="#socket-accept-with-value"><code>(SOCKET-ACCEPT-WITH SERVER-SOCKET OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-network.lisp#L215-L225">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadionetwork-class">MonadIoNetwork</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#serversocket-type">ServerSocket</a> &rarr; (<a href="#connectionsocket-type">ConnectionSocket</a> &rarr; (:C :D)) &rarr; (:C :D))</code><p class=docstring>Accept a connection with a new client and run operation OP. Guarantees that the
socket will close on cleanup.

Note: If you fork a thread inside this, the operation on this thread will probably finish
and close the socket before you intend. For multithreaded uses, use
socket-accept-fork-with.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-network-do-byte-socket-accept-fork-with-macro><a href="#io-gen-impl-network-do-byte-socket-accept-fork-with-macro"><code>DO-BYTE-SOCKET-ACCEPT-FORK-WITH ((SOCKET-SYM (SERVER-SOCKET)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Accept a byte-stream connection with a new client and run operation OP on a new thread.
Guarantees that the socket will close on cleanup. Returns a handle to the forked thread.</p><h4
    id=io-gen-impl-network-do-socket-listen-with-macro><a href="#io-gen-impl-network-do-socket-listen-with-macro"><code>DO-SOCKET-LISTEN-WITH ((SOCKET-SYM (HOSTNAME PORT)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run operation OP with a new server socket, listening on HOSTNAME and PORT. Guarantees
that the socket will close on cleanup.</p><h4
    id=io-gen-impl-network-do-socket-accept-fork-with-macro><a href="#io-gen-impl-network-do-socket-accept-fork-with-macro"><code>DO-SOCKET-ACCEPT-FORK-WITH ((SOCKET-SYM (SERVER-SOCKET)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Accept a connection with a new client and run operation OP on a new thread.
Guarantees that the socket will close on cleanup. Returns a handle to the forked thread.</p><h4
    id=io-gen-impl-network-do-socket-connect-with-macro><a href="#io-gen-impl-network-do-socket-connect-with-macro"><code>DO-SOCKET-CONNECT-WITH ((SOCKET-SYM (HOSTNAME PORT)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run operation OP with a connection to an open server socket at HOSTNAME and PORT.
Guarantees that the socket will close on cleanup.</p><h4
    id=io-gen-impl-network-do-socket-accept-with-macro><a href="#io-gen-impl-network-do-socket-accept-with-macro"><code>DO-SOCKET-ACCEPT-WITH ((SOCKET-SYM (SERVER-SOCKET)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Accept a connection with a new client and run operation OP. Guarantees that the
socket will close on cleanup.

Note: If you fork a thread inside this, the operation on this thread will probably finish
and close the socket before you intend. For multithreaded uses, use
socket-accept-fork-with.</p><h4
    id=io-classes-monad-io-network-derive-monad-io-network-macro><a href="#io-classes-monad-io-network-derive-monad-io-network-macro"><code>DERIVE-MONAD-IO-NETWORK (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoNetwork for a monad transformer.

Example:
  (derive-monad-io-network :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-network-do-byte-socket-accept-with-macro><a href="#io-gen-impl-network-do-byte-socket-accept-with-macro"><code>DO-BYTE-SOCKET-ACCEPT-WITH ((SOCKET-SYM (SERVER-SOCKET)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Accept a byte-stream connection with a new client and run operation OP. Guarantees that the
socket will close on cleanup.

Note: If you fork a thread inside this, the operation on this thread will probably finish
and close the socket before you intend. For multithreaded uses, use
byte-socket-accept-fork-with.</p><h4
    id=io-gen-impl-network-do-byte-socket-listen-with-macro><a href="#io-gen-impl-network-do-byte-socket-listen-with-macro"><code>DO-BYTE-SOCKET-LISTEN-WITH ((SOCKET-SYM (HOSTNAME PORT)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run operation OP with a new byte-stream server socket, listening on HOSTNAME and PORT. Guarantees
that the socket will close on cleanup.</p><h4
    id=io-gen-impl-network-do-byte-socket-connect-with-macro><a href="#io-gen-impl-network-do-byte-socket-connect-with-macro"><code>DO-BYTE-SOCKET-CONNECT-WITH ((SOCKET-SYM (HOSTNAME PORT)) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run operation OP with a byte-stream connection to an open server socket at HOSTNAME and PORT.
Guarantees that the socket will close on cleanup.</p><h4
    id=io-gen-impl-network-implement-monad-io-network-macro><a href="#io-gen-impl-network-implement-monad-io-network-macro"><code>IMPLEMENT-MONAD-IO-NETWORK (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/conc/parking-package">Package <code>IO/CONC/PARKING</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=parkingset-type><a href="#parkingset-type"><code>ParkingSet</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L38-L50">src</a></sub></sup></sub></sup></h4><p class=docstring>ParkingSet is a thread-safe list of parked threads. A parking thread can atomically
subscibe and park on a Parking Set, and a signalling thread can atomically unpark all
parkers on a ParkingSet.

In general, ParkingSet is the preferred way to park and unpark threads. The lower-level
parking functions exposed by the MonadIoThread and Runtime classes should only be used
if ParkingSet doesn&#39;t provide enough functionality for the algorithm.

Concurrent:
  - ParkingSet&#39;s algorithms are lock free, but individual threads can block for a very
    short window if contention on the parking set is very high.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#parkingset-type">ParkingSet</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=park-in-sets-if-with-value><a href="#park-in-sets-if-with-value"><code>(PARK-IN-SETS-IF-WITH SHOULD-PARK? STRATEGY PSETS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L122-L143">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((:C <a href="#boolean-type">Boolean</a>) &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#list-type">List</a> <a href="#parkingset-type">ParkingSet</a>) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSETS if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=park-in-set-if-with-value><a href="#park-in-set-if-with-value"><code>(PARK-IN-SET-IF-WITH SHOULD-PARK? STRATEGY PSET)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L163-L183">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((:C <a href="#boolean-type">Boolean</a>) &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; <a href="#parkingset-type">ParkingSet</a> &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSET if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=park-in-sets-if-value><a href="#park-in-sets-if-value"><code>(PARK-IN-SETS-IF SHOULD-PARK? PSETS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L148-L158">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((:C <a href="#boolean-type">Boolean</a>) &rarr; (<a href="#list-type">List</a> <a href="#parkingset-type">ParkingSet</a>) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSETS if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=new-parking-set-value><a href="#new-parking-set-value"><code>NEW-PARKING-SET</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L59-L61">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#monadio-class">MonadIo</a> :A &rArr; (:A <a href="#parkingset-type">ParkingSet</a>)</code><p class=docstring>Create a new ParkingSet.</p><h4 id=park-in-set-if-value><a href="#park-in-set-if-value"><code>(PARK-IN-SET-IF SHOULD-PARK? PSET)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L188-L198">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#baseio-class">BaseIo</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadio-class">MonadIo</a> :D) &rArr; ((:C <a href="#boolean-type">Boolean</a>) &rarr; <a href="#parkingset-type">ParkingSet</a> &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSET if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=unpark-set-value><a href="#unpark-set-value"><code>(UNPARK-SET PSET)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/parking.lisp#L210-L215">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#monadio-class">MonadIo</a> :A &rArr; (<a href="#parkingset-type">ParkingSet</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><p class=docstring>Atomically reset PSET, then attempt to unpark all threads parked on the set.

Concurrent:
  - Can briefly block while trying to reset the set or unpark a parked thread</p><h4 id=park-in-sets-if_-value><a href="#park-in-sets-if_-value"><code>(PARK-IN-SETS-IF_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/parking.lisp#L23-L33">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#monadio-class">MonadIo</a> :A &rArr; ((<a href="#io-type">IO</a> <a href="#boolean-type">Boolean</a>) &rarr; (<a href="#list-type">List</a> <a href="#parkingset-type">ParkingSet</a>) &rarr; (:A <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSETS if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p><h4 id=park-in-set-if_-value><a href="#park-in-set-if_-value"><code>(PARK-IN-SET-IF_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/parking.lisp#L37-L47">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#monadio-class">MonadIo</a> :A &rArr; ((<a href="#io-type">IO</a> <a href="#boolean-type">Boolean</a>) &rarr; <a href="#parkingset-type">ParkingSet</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><p class=docstring>Parks the current thread in PSET if SHOULD-PARK? returns True. Will park the thread
until woken by an unpark from another thread. Upon an unpark, the thread will resume even
if SHOULD-PARK? is False! SHOULD-PARK? is only checked to determine if the thread should
park, *not* if it should resume.

Concurrent:
  - WARNING: SHOULD-PARK? must not block, or the thread could be left blocked in a masked
    state.
  - Can briefly block while trying to park the thread, if contended.</p></div>
      <hr><h1 id="io/conc/scheduler-package">Package <code>IO/CONC/SCHEDULER</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=scheduler-class><a href="#scheduler-class"><code>Scheduler</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/conc/scheduler.lisp#L24-L65">src</a></sub></sup></sub></sup></h4><code><a href="#scheduler-class">Scheduler</a> :A</code><p class=docstring>A Scheduler distributes work from producer threads to worker threads. Generally, the
Scheduler is allowed to completely control the worker threads: it can sleep, block, spin,
etc., as dictated by the Scheduler algorithm. However, it must give producer threads the
choice of how to respond to the state of the Scheduler. For example, if the Scheduler is
bounded and its internal queue is full, the producer thread chooses whether to block or
fail based on its choice of which submit function to call.

The main purpose of a Scheduler is to pass into a WorkerPool to configure its scheduling
algorithm. A Scheduler could have uses in other contexts.

A Scheduler may be bounded or unbounded and still satisfy the Scheduler interface. For
unbounded schedulers, `submit` will never block and `try-submit` will always succeed.

Threads asking for work will submit a thread-index to the scheduler. The Scheduler can
choose to use this, particularly if it maintains a separate queue for each thread, or
choose to ignore it, if it only uses a single queue for all threads. Thread index values
should be 0-indexed, from [0, n-threads).</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>SUBMIT :: <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:D &rarr; (:E :D) &rarr; (:C <a href="#unit-type">Unit</a>))</code><span><br>Submit a new item to the Scheduler.&#xA;&#xA;Concurrent:&#xA;  - Blocks if the Scheduler is full. Only bounded Schedulers will ever be full.</span>
        <li class=methods-item><code>SUBMIT-WITH :: <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:D &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (:E :D) &rarr; (:C <a href="#unit-type">Unit</a>))</code><span><br>Submit a new item to the Scheduler.&#xA;&#xA;Concurrent:&#xA;  - Blocks if the Scheduler is full, possibly timing out based on STRATEGY. Only bounded&#xA;Schedulers will ever be full.</span>
        <li class=methods-item><code>TRY-SUBMIT :: <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:D &rarr; (:E :D) &rarr; (:C <a href="#boolean-type">Boolean</a>))</code><span><br>Attempt to submit a new item to the Scheduler. Returns `True` if the item was added,&#xA;or `False` if the Scheduler was full. Only bounded Schedulers can be full.</span>
        <li class=methods-item><code>TAKE-ITEM :: <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:D :E) &rarr; (:C :E))</code><span><br>Take the next item from the Scheduler for the given thread.&#xA;&#xA;Concurrent:&#xA;  - May block, sleep, spin, or do anything else to the requesting thread, except&#xA;    (1) leave it masked after returning, or (2) stop the thread.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#scheduler-class">Scheduler</a> <a href="#ringbufferscheduler-type">RingBufferScheduler</a></code>
         <li class=instances-item><code><a href="#scheduler-class">Scheduler</a> <a href="#mchanscheduler-type">MChanScheduler</a></code></ul></details></div>
      <hr><h1 id="io/conc/future-package">Package <code>IO/CONC/FUTURE</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=future-type><a href="#future-type"><code>Future :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L32-L42">src</a></sub></sup></sub></sup></h4><p class=docstring>Container for an value that will eventually be returned by a concurrent operation.

Concurrent:
  - Future&#39;s `(Concurrent Future :a)` instance defers to the underlying thread, so it takes
    on masking semantics of the underyling thread&#39;s `Concurrent` instance.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#future-type">Future</a> :A) :A</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#future-type">Future</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=try-read-future-value><a href="#try-read-future-value"><code>(TRY-READ-FUTURE FUTURE)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L88-L100">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :D) (<a href="#monadexception-class">MonadException</a> :D) &rArr; ((<a href="#future-type">Future</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Try to read the current value from FUTURE, returning NONE
if it is not available. Raises any exceptions in the awaiting thread
that were raised in the future thread.</p><h4 id=fork-future-value><a href="#fork-future-value"><code>(FORK-FUTURE TASK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L48-L74">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :D) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :F) &rArr; ((:D :E) &rarr; (:F (<a href="#future-type">Future</a> :E)))</code><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p><h4 id=fork-future_-value><a href="#fork-future_-value"><code>(FORK-FUTURE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-future.lisp#L25-L29">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B (<a href="#future-type">Future</a> :A)))</code><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-conc-future-do-fork-future-macro><a href="#io-gen-impl-conc-future-do-fork-future-macro"><code>DO-FORK-FUTURE (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p><h4
    id=io-io-impl-future-do-fork-future_-macro><a href="#io-io-impl-future-do-fork-future_-macro"><code>DO-FORK-FUTURE_ (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/conc/atomic-package">Package <code>IO/CONC/ATOMIC</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=atvar-type><a href="#atvar-type"><code>AtVar</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L39-L43">src</a></sub></sup></sub></sup></h4><p class=docstring>A container that can be read and modified atomically.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#atvar-type">AtVar</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=modify-swap-value><a href="#modify-swap-value"><code>(MODIFY-SWAP ATM F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L82-L90">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Atomically modify `atm` by applying `f` and return the old value. `f` must be a pure
function. If `f` throws an error, `atm` will be unchanged and the error will be handleable
via `MonadException`.

Concurrent:
  - WARNING: `f` will be retried each time the calling thread loses the race to update
    `atm`, so `f` must be pure.</p><h4 id=new-at-var-value><a href="#new-at-var-value"><code>(NEW-AT-VAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L52-L54">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; (:A &rarr; (:B (<a href="#atvar-type">AtVar</a> :A)))</code><p class=docstring>Create a new AtVar containing `val`.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY ATM F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L70-L78">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadio-class">MonadIo</a> :B) (<a href="#monadexception-class">MonadException</a> :B) &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Atomically modify `atm` by applying `f` and return the new value. `f` must be a pure
function. If `f` throws an error, `atm` will be unchanged and the error will be handleable
via `MonadException`.

Concurrent:
  - WARNING: `f` will be retried each time the calling thread loses the race to update
    `atm`, so `f` must be pure.</p><h4 id=write-value><a href="#write-value"><code>(WRITE ATM VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L64-L66">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; :A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Atomically write a new value to `atm`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L58-L60">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:B :A))</code><p class=docstring>Atomically read the value from `atm`.</p><h4 id=push-value><a href="#push-value"><code>(PUSH ATM ELT)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L94-L96">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> (<a href="#list-type">List</a> :A)) &rarr; :A &rarr; (:B (<a href="#list-type">List</a> :A)))</code><p class=docstring>Atomically push a value onto an atomic list. Returns the new list.</p><h4 id=pop-value><a href="#pop-value"><code>(POP ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L100-L102">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> (<a href="#list-type">List</a> :A)) &rarr; (:B (<a href="#optional-type">Optional</a> :A)))</code><p class=docstring>Atomically pop and retrieve the head of an atomic list.</p></div>
      <hr><h1 id="io/conc/mvar-package">Package <code>IO/CONC/MVAR</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=mchan-type><a href="#mchan-type"><code>MChan :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L506-L509">src</a></sub></sup></sub></sup></h4><p class=docstring>A synchronized FIFO queue to pass data directionally between threads.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#mchan-type">MChan</a> :A)</code></ul></details><h4 id=mvar-type><a href="#mvar-type"><code>MVar :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L62-L71">src</a></sub></sup></sub></sup></h4><p class=docstring>A synchronized container that can be empty or hold an :a.

All critical MVar operations are masked. However, irresponsible stopping could still cause
deadlocks and other race conditions.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#mvar-type">MVar</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=take-mvar-masked-with-value><a href="#take-mvar-masked-with-value"><code>(TAKE-MVAR-MASKED-WITH STRATEGY MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L133-L145">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - WARNING: Leaves the thread masked when returns to protect caller&#39;s critical regions
    based on consuming and restoring MVar to a valid state. See MChan for an example.
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar-masked`) are woken individual on succesfull puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=try-take-mvar-masked-value><a href="#try-take-mvar-masked-value"><code>(TRY-TAKE-MVAR-MASKED MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L304-L314">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to immediately take a value from an MVar. Returns None if empty.

Concurrent:
  - WARNING: Leaves the thread masked when returns to protect caller&#39;s critical regions
    based on consuming and restoring MVar to a valid state. See MChan for an example.
  - Can briefly block while waiting to empty the MVar, if contended
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=take-mvar-masked-value><a href="#take-mvar-masked-value"><code>(TAKE-MVAR-MASKED MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L149-L159">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - WARNING: Leaves the thread masked when returns to protect caller&#39;s critical regions
    based on consuming and restoring MVar to a valid state. See MChan for an example.
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar-masked`) are woken individual on succesfull puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=take-mvar-with-value><a href="#take-mvar-with-value"><code>(TAKE-MVAR-WITH STRATEGY MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L163-L177">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar`) are woken individual on succesful puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=swap-mvar-with-value><a href="#swap-mvar-with-value"><code>(SWAP-MVAR-WITH STRATEGY MVAR NEW-VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L389-L425">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D :C))</code><p class=docstring>Atomically replace the value in an MVar and return the old value.

Concurrent:
  - Blocks while the MVar is empty
  - Wakes the next blocking read-consumer when `swap-mvar` completes</p><h4 id=read-mvar-with-value><a href="#read-mvar-with-value"><code>(READ-MVAR-WITH STRATEGY MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L355-L370">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Read a value from an MVar, blocking until one is available. Does not consume value.

Concurrent:
  - Blocks while the MVar is empty
  - Blocking read-non-consumers (including `read-mvar`) are woken simultaneously on 
    succesful put. Data is handed directly to woken readers, which don&#39;t contend on mvar.</p><h4 id=new-empty-mvar-value><a href="#new-empty-mvar-value"><code>NEW-EMPTY-MVAR</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L86-L93">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C (<a href="#mvar-type">MVar</a> :D))</code><p class=docstring>Create a new empty MVar.</p><h4 id=new-empty-chan-value><a href="#new-empty-chan-value"><code>NEW-EMPTY-CHAN</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L512-L518">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C (<a href="#mchan-type">MChan</a> :D))</code><p class=docstring>Create a new empty channel.</p><h4 id=try-take-mvar-value><a href="#try-take-mvar-value"><code>(TRY-TAKE-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L289-L301">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to immediately take a value from an MVar. Returns None if empty.

Concurrent:
  - Can briefly block while waiting to empty the MVar, if contended
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=try-read-mvar-value><a href="#try-read-mvar-value"><code>(TRY-READ-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L383-L386">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to immediately read a value from an MVar. Returns None if empty.</p><h4 id=put-mvar-with-value><a href="#put-mvar-with-value"><code>(PUT-MVAR-WITH STRATEGY MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L192-L237">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Fill an empty MVar, blocking until it becomes empty.

Concurrent:
  - Blocks while the MVar is full
  - Writers (including `put-mvar`) are woken individual on succesful takes in order
    of acquisition
  - On succesful put, blocking read-consumers are woken individually in order of acquisition
  - On succesful put, all blocking read-non-consumers are woken simultaneously. New data
    is handed directly to woken read-non-consumers so they don&#39;t contend on the MVar.</p><h4 id=pop-chan-with-value><a href="#pop-chan-with-value"><code>(POP-CHAN-WITH STRATEGY CHAN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L537-L544">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#mchan-type">MChan</a> :C) &rarr; (:D :C))</code><p class=docstring>Pop the front value in CHAN. Blocks while CHAN is empty.</p><h4 id=is-empty-mvar-value><a href="#is-empty-mvar-value"><code>(IS-EMPTY-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L439-L442">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Return True if the MVar is currently empty.</p><h4 id=try-put-mvar-value><a href="#try-put-mvar-value"><code>(TRY-PUT-MVAR MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L317-L352">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Attempt to immediately put a value into an MVar. Returns True if succeeded.

Concurrent:
  - Can briefly block while waiting to fill the MVar, if contended
  - On succesful put, blocking read-consumers are woken individually in order of acquisition
  - On succesful put, all blocking read-non-consumers are woken simultaneously. New data
    is handed directly to woken read-non-consumers so they don&#39;t contend on the MVar.</p><h4 id=try-pop-chan-value><a href="#try-pop-chan-value"><code>(TRY-POP-CHAN CHAN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L547-L556">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mchan-type">MChan</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to pop the front value in CHAN. Does not block.</p><h4 id=with-mvar-value><a href="#with-mvar-value"><code>(WITH-MVAR MVAR OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L453-L476">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; ((<a href="#mvar-type">MVar</a> :D) &rarr; (:D &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Restore the MVar value and return the result of the operation.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p><h4 id=take-mvar-value><a href="#take-mvar-value"><code>(TAKE-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L181-L189">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar`) are woken individual on succesful puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=swap-mvar-value><a href="#swap-mvar-value"><code>(SWAP-MVAR MVAR NEW-VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L429-L435">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D :C))</code><p class=docstring>Atomically replace the value in an MVar and return the old value.

Concurrent:
  - Blocks while the MVar is empty
  - Wakes the next blocking read-consumer when `swap-mvar` completes</p><h4 id=read-mvar-value><a href="#read-mvar-value"><code>(READ-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L373-L380">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Read a value from an MVar, blocking until one is available. Does not consume value.

Concurrent:
  - Blocks while the MVar is empty
  - Blocking read-non-consumers (including `read-mvar`) are woken simultaneously on 
    succesful put. Data is handed directly to woken readers, which don&#39;t contend on mvar.</p><h4 id=push-chan-value><a href="#push-chan-value"><code>(PUSH-CHAN CHAN VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L521-L528">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mchan-type">MChan</a> :C) &rarr; :C &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Push VAL onto CHAN.</p><h4 id=put-mvar-value><a href="#put-mvar-value"><code>(PUT-MVAR MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L241-L251">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Fill an empty MVar, blocking until it becomes empty.

Concurrent:
  - Blocks while the MVar is full
  - Writers (including `put-mvar`) are woken individual on succesful takes in order
    of acquisition
  - On succesful put, blocking read-consumers are woken individually in order of acquisition
  - On succesful put, all blocking read-non-consumers are woken simultaneously. New data
    is handed directly to woken read-non-consumers so they don&#39;t contend on the MVar.</p><h4 id=pop-chan-value><a href="#pop-chan-value"><code>(POP-CHAN CHAN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L532-L534">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mchan-type">MChan</a> :C) &rarr; (:D :C))</code><p class=docstring>Pop the front value in CHAN. Blocks while CHAN is empty.</p><h4 id=new-mvar-value><a href="#new-mvar-value"><code>(NEW-MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L75-L82">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (:C &rarr; (:D (<a href="#mvar-type">MVar</a> :C)))</code><p class=docstring>Create a new MVar containing VAL.</p><h4 id=with-mvar_-value><a href="#with-mvar_-value"><code>(WITH-MVAR_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-mvar.lisp#L25-L38">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :C) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; ((<a href="#mvar-type">MVar</a> :A) &rarr; (:A &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Restore the MVar value and return the result of the operation.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-io-impl-mvar-do-with-mvar_-macro><a href="#io-io-impl-mvar-do-with-mvar_-macro"><code>DO-WITH-MVAR_ ((SYM MVAR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Stores the result of the operation in the MVar and returns.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p></div>
      <hr><h1 id="io/conc/group-package">Package <code>IO/CONC/GROUP</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=concurrentgroup-type><a href="#concurrentgroup-type"><code>ConcurrentGroup :A :B</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L32-L56">src</a></sub></sup></sub></sup></h4><p class=docstring>Handles masking, stopping, and awaiting a group of Concurrents as a unit. ConcurrentGroup
does not pass messages/data. For more structured uses, see WorkerPool.

ConcurrentGroup provides the following guarantees:
* Masking/unmasking the group is atomic. If another thread attempts to stop the group, it will
  either stop all of the Concurrents or none of them.
* Stopping the group sends the stop signal to all of the enclosed Concurrents.
* Awaiting the group blocks until all of the enclosed Concurrents have completed.
* Awaiting the group will error if any one of the enclosed Concurrents errored.
* Calling unmask-finally on the group runs the callback on each Concurrent separately, not
  once on the thread calling (unmask-finally).

ConcurrentGroup&#39;s guarantees are only valid if management of the enclosed Concurrents is
done through the group. For example, if one thread tries to mask the group while another
thread tries to stop one of the individual Concurrents in the group, then the second
thread might stop the individual Concurrent before the first thread has a chance to mask
it.

Concurrent:
  - The `(Concurrent ConcurrentGroup :a)&#39; instance masks `stop`, `mask`, `unmask`,
    and `unmask-finally` to guarantee atomicity of the enclosed Concurrents
  - `await` is not masked</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> :A :B &rArr; <a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B) (<a href="#list-type">List</a> :B)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=enclose-group-value><a href="#enclose-group-value"><code>(ENCLOSE-GROUP CONCURRENTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L83-L87">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :D) (<a href="#concurrent-class">Concurrent</a> :C :E) &rArr; ((<a href="#list-type">List</a> :C) &rarr; (:D (<a href="#concurrentgroup-type">ConcurrentGroup</a> :C :E)))</code><p class=docstring>Enclose already forked Concurrents in a ConcurrentGroup.

Warning: After calling, the enclosed Concurrents should only be managed through the group.</p><h4 id=fork-group-value><a href="#fork-group-value"><code>(FORK-GROUP FORK-CONCURRENTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L70-L79">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#concurrent-class">Concurrent</a> :D :E) &rArr; ((<a href="#list-type">List</a> (:C :D)) &rarr; (:C (<a href="#concurrentgroup-type">ConcurrentGroup</a> :D :E)))</code><p class=docstring>Run a list of IO operations that each forks a Concurrent. Enclose the forked Concurrents in a
ConcurrentGroup.

Concurrent:
  - Does not mask the forking operation, so it is possible to partially fork if stopped.
    To guarantee forking completion, caller should mask the call to `fork-group`.</p></div>
      <hr><h1 id="io/conc/stm-package">Package <code>IO/CONC/STM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=tvar-type><a href="#tvar-type"><code>TVar</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L62-L64">src</a></sub></sup></sub></sup></h4><p class=docstring>A Transaction Variable that can be read and modified inside an STM transaction.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code>(<a href="#eq-class">Eq</a> (<a href="#cell-type">Cell</a> :A)) (<a href="#eq-class">Eq</a> <a href="#parkingset-type">ParkingSet</a>) &rArr; <a href="#eq-class">Eq</a> (<a href="#tvar-type">TVar</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#tvar-type">TVar</a> :A)</code></ul></details><h4 id=stm-type><a href="#stm-type"><code>STM</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L116-L118">src</a></sub></sup></sub></sup></h4><p class=docstring>A transaction that can be run using `run-tx`.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code>(<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadio-class">MonadIo</a> :A) &rArr; <a href="#monadexception-class">MonadException</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#functor-class">Functor</a> :A &rArr; <a href="#functor-class">Functor</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#applicative-class">Applicative</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monad-class">Monad</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> ((<a href="#stm-type">STM</a> :A) :B)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=modify-swap-tvar-value><a href="#modify-swap-tvar-value"><code>(MODIFY-SWAP-TVAR TVAR F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L597-L611">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; (:A &rarr; :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Modify a mutable variable inside an atomic transaction. Returns the old value.</p><h4 id=modify-tvar-value><a href="#modify-tvar-value"><code>(MODIFY-TVAR TVAR F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L580-L594">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; (:A &rarr; :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Modify a mutable variable inside an atomic transaction. Returns the new value.</p><h4 id=write-tvar-value><a href="#write-tvar-value"><code>(WRITE-TVAR TVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L556-L560">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; :A &rarr; ((<a href="#stm-type">STM</a> :B) <a href="#unit-type">Unit</a>))</code><p class=docstring>Write to a mutable variable inside an atomic transaction.</p><h4 id=retry-with-value><a href="#retry-with-value"><code>(RETRY-WITH STRATEGY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L653-L672">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :A &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; ((<a href="#stm-type">STM</a> :A) :B))</code><p class=docstring>Retry the current operation because the observed state is invalid. Waits for a write
transaction to commit somewhere else, and then tries this transaction again.

This is useful if the transaction needs to wait for other threads to update the data
before it can continue. For example, if the transaction reads from a (TVar Queue) and the
queue is empty, it must wait until another thread pushes onto the queue before it can
continue.

Concurrent:
  - When the transaction runs, executing retry will abort the transaction and sleep the
    thread. The thread will sleep until any relevant write transaction commits to the STM,
    when the retrying thread will wake and retry its transaction. A write transaction
    only triggers a retry if it writes to a TVar that was read before `retry` was called.
  - Will timeout depending on strategy.
</p><h4 id=swap-tvar-value><a href="#swap-tvar-value"><code>(SWAP-TVAR TVAR NEW-VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L563-L577">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; :A &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Swap the value of a mutable variable inside an atomic transaction. Returns the old
value.</p><h4 id=read-tvar-value><a href="#read-tvar-value"><code>(READ-TVAR TVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L547-L552">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Read a mutable variable inside an atomic transaction.</p><h4 id=new-tvar-value><a href="#new-tvar-value"><code>(NEW-TVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L429-L431">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; (:A &rarr; (:B (<a href="#tvar-type">TVar</a> :A)))</code><p class=docstring>Create a mutable variable that can be used inside an atomic transaction.</p><h4 id=or-else-value><a href="#or-else-value"><code>(OR-ELSE TX-A TX-B)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L694-L710">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :A &rArr; (((<a href="#stm-type">STM</a> :A) :B) &rarr; ((<a href="#stm-type">STM</a> :A) :B) &rarr; ((<a href="#stm-type">STM</a> :A) :B))</code><p class=docstring>Run TX-A. If it signals a retry, run TX-b. If both transactions signal a
retry, then the entire transaction retries.</p><h4 id=run-tx-value><a href="#run-tx-value"><code>(RUN-TX TX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L713-L740">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (((<a href="#stm-type">STM</a> :C) :D) &rarr; (:C :D))</code><p class=docstring>Run an atomic transaction. If the transaction raises an exception, the transaction
is aborted and the exception is re-raised.

WARNING: The STM can abort and re-run the transaction repeatedly, until it completes with
a consistent snapshot of the data. Therefore, TX must be pure.</p><h4 id=retry-value><a href="#retry-value"><code>RETRY</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L676-L691">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :A &rArr; ((<a href="#stm-type">STM</a> :A) :B)</code><p class=docstring>Retry the current operation because the observed state is invalid. Waits for a write
transaction to commit somewhere else, and then tries this transaction again.

This is useful if the transaction needs to wait for other threads to update the data
before it can continue. For example, if the transaction reads from a (TVar Queue) and the
queue is empty, it must wait until another thread pushes onto the queue before it can
continue.

Concurrent:
  - When the transaction runs, executing retry will abort the transaction and sleep the
    thread. The thread will sleep until any relevant write transaction commits to the STM,
    when the retrying thread will wake and retry its transaction. A write transaction
    only triggers a retry if it writes to a TVar that was read before `retry` was called.
</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-gen-impl-conc-stm-do-run-tx-macro><a href="#io-gen-impl-conc-stm-do-run-tx-macro"><code>DO-RUN-TX (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run an atomic transaction. If the transaction raises an exception, the transaction
is aborted and the exception is re-raised.

WARNING: The STM can abort and re-run the transaction repeatedly, until it completes with
a consistent snapshot of the data. Therefore, TX must be pure.</p></div>
      <hr><h1 id="io/conc/mchan-scheduler-package">Package <code>IO/CONC/MCHAN-SCHEDULER</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=mchanscheduler-type><a href="#mchanscheduler-type"><code>MChanScheduler</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/mchan-scheduler.lisp#L22-L28">src</a></sub></sup></sub></sup></h4><p class=docstring>An MChanScheduler uses a single MChan internally to manage tasks. Producers submit
tasks onto the end of the MChan. Worker threads pop items, one-by-one, from the front of
the MChan.

MChanScheduler is unbounded.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#mchanscheduler-type">MChanScheduler</a> :A)</code>
         <li class=instances-item><code><a href="#scheduler-class">Scheduler</a> <a href="#mchanscheduler-type">MChanScheduler</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=new-mchan-scheduler-value><a href="#new-mchan-scheduler-value"><code>NEW-MCHAN-SCHEDULER</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/mchan-scheduler.lisp#L32-L33">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C (<a href="#mchanscheduler-type">MChanScheduler</a> :D))</code></div>
      <hr><h1 id="io/conc/worker-pool-package">Package <code>IO/CONC/WORKER-POOL</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=workerpool-type><a href="#workerpool-type"><code>WorkerPool :A :B :C</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L34-L38">src</a></sub></sup></sub></sup></h4><p class=docstring>A pool of worker threads that execute jobs submitted to the pool.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code>(<a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A <a href="#unit-type">Unit</a>) (<a href="#list-type">List</a> <a href="#unit-type">Unit</a>)) (<a href="#scheduler-class">Scheduler</a> :B) &rArr; <a href="#concurrent-class">Concurrent</a> (((<a href="#workerpool-type">WorkerPool</a> :B) :C) :A) <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (((<a href="#workerpool-type">WorkerPool</a> :A) :B) :C)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=request-shutdown-value><a href="#request-shutdown-value"><code>(REQUEST-SHUTDOWN POOL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L107-L113">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :D :E) (<a href="#monadexception-class">MonadException</a> :E) (<a href="#scheduler-class">Scheduler</a> :B) &rArr; ((((<a href="#workerpool-type">WorkerPool</a> :B) :C) :D) &rarr; (:E <a href="#unit-type">Unit</a>))</code><p class=docstring>Request a shutdown. The threads in the pool will shutdown when all of the jobs already
in the queue are completed.

To immediately stop the threads, use `stop`.</p><h4 id=new-worker-pool-value><a href="#new-worker-pool-value"><code>(NEW-WORKER-POOL N-THREADS SCHEDULER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L61-L73">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :E :D) (<a href="#unliftio-class">UnliftIo</a> :C :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :E :C) (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadexception-class">MonadException</a> :D) (<a href="#concurrent-class">Concurrent</a> :E <a href="#unit-type">Unit</a>) (<a href="#liftio-class">LiftIo</a> :C :D) (<a href="#scheduler-class">Scheduler</a> :B) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:B (<a href="#optional-type">Optional</a> (:C <a href="#unit-type">Unit</a>))) &rarr; (:D (((<a href="#workerpool-type">WorkerPool</a> :B) :C) :E)))</code><p class=docstring>Create a new worker pool. Automatically forks N-THREADS worker threads.</p><h4 id=submit-job-value><a href="#submit-job-value"><code>(SUBMIT-JOB POOL JOB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L96-L103">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#unliftio-class">UnliftIo</a> :E :C) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadiothread-class">MonadIoThread</a> :A :D :C) (<a href="#monadexception-class">MonadException</a> :C) (<a href="#scheduler-class">Scheduler</a> :B) &rArr; ((((<a href="#workerpool-type">WorkerPool</a> :B) :C) :D) &rarr; (:E :F) &rarr; (:G <a href="#unit-type">Unit</a>))</code><p class=docstring>Submit a job to the worker pool. Any jobs submitted after a shutdown request will
be ignored.

Concurrent:
  - If the pool&#39;s scheduler is backed by a bounded data structure, then this can block
    while the scheduler is full.</p><h4 id=new-worker-pool_-value><a href="#new-worker-pool_-value"><code>(NEW-WORKER-POOL_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/worker-pool.lisp#L31-L31">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :B) (<a href="#scheduler-class">Scheduler</a> :A) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:A (<a href="#optional-type">Optional</a> (<a href="#io-type">IO</a> <a href="#unit-type">Unit</a>))) &rarr; (:B (((<a href="#workerpool-type">WorkerPool</a> :A) <a href="#io-type">IO</a>) <a href="#iothread-type">IoThread</a>)))</code><h4 id=submit-job_-value><a href="#submit-job_-value"><code>(SUBMIT-JOB_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/worker-pool.lisp#L36-L36">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :C) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) (<a href="#scheduler-class">Scheduler</a> :A) &rArr; ((((<a href="#workerpool-type">WorkerPool</a> :A) <a href="#io-type">IO</a>) <a href="#iothread-type">IoThread</a>) &rarr; (<a href="#io-type">IO</a> :B) &rarr; (:C <a href="#unit-type">Unit</a>))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-conc-worker-pool-do-submit-job-with-macro><a href="#io-gen-impl-conc-worker-pool-do-submit-job-with-macro"><code>DO-SUBMIT-JOB-WITH (STRATEGY POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-gen-impl-conc-worker-pool-do-submit-job-macro><a href="#io-gen-impl-conc-worker-pool-do-submit-job-macro"><code>DO-SUBMIT-JOB (POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-conc-worker-pool-do-submit-job_-macro><a href="#io-io-impl-conc-worker-pool-do-submit-job_-macro"><code>DO-SUBMIT-JOB_ (POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-conc-worker-pool-do-submit-job-with_-macro><a href="#io-io-impl-conc-worker-pool-do-submit-job-with_-macro"><code>DO-SUBMIT-JOB-WITH_ (STRATEGY POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/conc/ring-buffer-package">Package <code>IO/CONC/RING-BUFFER</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=ringbufferscheduler-type><a href="#ringbufferscheduler-type"><code>RingBufferScheduler</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer-scheduler.lisp#L34-L38">src</a></sub></sup></sub></sup></h4><p class=docstring>A RingBufferScheduler uses a single RingBuffer internally to manage tasks.

MChanScheduler is bounded.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#ringbufferscheduler-type">RingBufferScheduler</a> :A)</code>
         <li class=instances-item><code><a href="#scheduler-class">Scheduler</a> <a href="#ringbufferscheduler-type">RingBufferScheduler</a></code></ul></details><h4 id=schedulererror-type><a href="#schedulererror-type"><code>SchedulerError</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer-scheduler.lisp#L24-L25">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#schedulererror-type">SchedulerError</a></code>
         <li class=instances-item><code><a href="#signalable-class">Signalable</a> <a href="#schedulererror-type">SchedulerError</a></code></ul></details></div>
      <hr><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=ringbuffer-type><a href="#ringbuffer-type"><code>RingBuffer :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L45-L58">src</a></sub></sup></sub></sup></h4><p class=docstring>A bounded FIFO Multi-Producer, Multi-Consumer Queue implemented as a RingBuffer.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#ringbuffer-type">RingBuffer</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=new-ring-buffer-scheduler-value><a href="#new-ring-buffer-scheduler-value"><code>(NEW-RING-BUFFER-SCHEDULER CAPACITY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer-scheduler.lisp#L43-L46">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:C (<a href="#ringbufferscheduler-type">RingBufferScheduler</a> :D)))</code><h4 id=new-ring-buffer-value><a href="#new-ring-buffer-value"><code>(NEW-RING-BUFFER CAPACITY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L253-L255">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:C (<a href="#ringbuffer-type">RingBuffer</a> :D)))</code><p class=docstring>Create a new ring buffer with the given capacity.</p><h4 id=enqueue-with-value><a href="#enqueue-with-value"><code>(ENQUEUE-WITH ELT STRATEGY BUFFER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L259-L265">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (:C &rarr; <a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#ringbuffer-type">RingBuffer</a> :C) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Add ELT to BUFFER.

Concurrent:
  - Can block acquiring lock on buffer.
  - If full, blocks until BUFFER is not full, possibly timing out based on STRATEGY.</p><h4 id=dequeue-with-value><a href="#dequeue-with-value"><code>(DEQUEUE-WITH STRATEGY BUFFER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L287-L293">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (<a href="#timeoutstrategy-type">TimeoutStrategy</a> &rarr; (<a href="#ringbuffer-type">RingBuffer</a> :C) &rarr; (:D :C))</code><p class=docstring>Pop an element from BUFFER.

Concurrent:
  - Can block briefly while acquiring lock on buffer.
  - If empty, blocks until BUFFER is not empty.</p><h4 id=try-enqueue-value><a href="#try-enqueue-value"><code>(TRY-ENQUEUE ELT BUFFER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L279-L283">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (:C &rarr; (<a href="#ringbuffer-type">RingBuffer</a> :C) &rarr; (:D <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Attempt to add ELT to BUFFER. Returns True if equeue succeeded, False otherwise.

Concurrent: Can block acquiring lock on buffer.</p><h4 id=enqueue-value><a href="#enqueue-value"><code>(ENQUEUE ELT BUFFER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L269-L275">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (:C &rarr; (<a href="#ringbuffer-type">RingBuffer</a> :C) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Add ELT to BUFFER.

Concurrent:
  - Can block acquiring lock on buffer.
  - If full, blocks until BUFFER is not full.</p><h4 id=dequeue-value><a href="#dequeue-value"><code>(DEQUEUE BUFFER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/ring-buffer.lisp#L297-L303">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#ringbuffer-type">RingBuffer</a> :C) &rarr; (:D :C))</code><p class=docstring>Pop an element from BUFFER.

Concurrent:
  - Can block briefly while acquiring lock on buffer.
  - If empty, blocks until BUFFER is not empty.</p></div>
      <hr><h1 id="io/io-all-package">Package <code>IO/IO-ALL</code></h1><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-io-all-derive-monad-io-all-macro><a href="#io-io-all-derive-monad-io-all-macro"><code>DERIVE-MONAD-IO-ALL (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><h4 id=io-io-all-implement-monad-io-all-macro><a href="#io-io-all-implement-monad-io-all-macro"><code>IMPLEMENT-MONAD-IO-ALL (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/stubs/term-package">Package <code>IO/STUBS/TERM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=termstubm-type><a href="#termstubm-type"><code>TermStubM</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L46-L46">src</a></sub></sup></sub></sup></h4><h4 id=termstub-type><a href="#termstub-type"><code>TermStub</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L47-L47">src</a></sub></sup></sub></sup></h4></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=run-term-stubm-value><a href="#run-term-stubm-value"><code>(RUN-TERM-STUBM OPM READ-LINE-INPUTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L74-L113">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monad-class">Monad</a> :A &rArr; ((((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A) :B) &rarr; (<a href="#list-type">List</a> <a href="#string-type">String</a>) &rarr; (:A (<a href="#tuple-type">Tuple</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>) :B)))</code><h4 id=run-term-stub-value><a href="#run-term-stub-value"><code>(RUN-TERM-STUB STUB-OP READ-LINE-INPUTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L116-L117">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) <a href="#identity-type">Identity</a>) :A) &rarr; (<a href="#list-type">List</a> <a href="#string-type">String</a>) &rarr; (<a href="#tuple-type">Tuple</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>) :A))</code></div>
      <hr>
     </div>
    </div>
   </article>
  </main>
  <script>(function(){
  function text(el){return (el&&el.textContent||"").trim()}
  function buildIndex(main){
    var items=[]
    var pkg=""
    var walker=document.createTreeWalker(main,NodeFilter.SHOW_ELEMENT,null,false)
    var node=walker.currentNode
    while(node){
      var tag=node.tagName
      if(tag==="H1"){
        var code=node.querySelector("code")
        pkg=text(code)||text(node)
      }else if(tag==="H4"){
        var a=node.querySelector('a[href^="#"]')
        if(a){
          var href=a.getAttribute("href")||""
          var name=text(a)
          var sub=node.querySelector("sub")
          var typ=""
          if(sub){
            typ=text(sub).split("·")[0].trim()
          }
          if(href&&name){
            items.push({name:name,href:href,typ:typ,pkg:pkg})
          }
        }
      }
      node=walker.nextNode()
    }
    return items
  }
  function el(tag,cls,txt){
    var d=document.createElement(tag)
    if(cls)d.className=cls
    if(txt!=null)d.textContent=txt
    return d
  }
  function setup(){
    var input=document.getElementById("symbol-search-input")
    var results=document.getElementById("search-results")
    var main=document.querySelector(".main-content")
    if(!input||!results||!main)return
    var items=buildIndex(main)
    var activeIndex=-1
    function clear(){
      results.innerHTML=""
      results.classList.remove("active")
      activeIndex=-1
    }
    function setActive(i){
      var children=results.querySelectorAll(".search-result-item")
      for(var k=0;k<children.length;k++)children[k].classList.remove("active")
      if(i<0||i>=children.length)return
      children[i].classList.add("active")
      children[i].scrollIntoView({block:"nearest"})
    }
    function render(q){
      q=(q||"").trim().toLowerCase()
      results.innerHTML=""
      activeIndex=-1
      if(!q){
        results.classList.remove("active")
        return
      }
      var out=[]
      for(var i=0;i<items.length;i++){
        var it=items[i]
        if(it.name.toLowerCase().indexOf(q)!==-1){
          out.push(it)
          if(out.length>=40)break
        }
      }
      for(var j=0;j<out.length;j++){
        var it2=out[j]
        var row=el("div","search-result-item")
        row.tabIndex=-1
        row.dataset.href=it2.href
        row.appendChild(el("span","search-result-symbol",it2.name))
        if(it2.typ)row.appendChild(el("span","search-result-type",it2.typ))
        if(it2.pkg)row.appendChild(el("div","search-result-package",it2.pkg))
        row.addEventListener("mousedown",(function(href){
          return function(e){
            e.preventDefault()
            window.location.hash=href.slice(1)
            clear()
            input.blur()
          }
        })(it2.href))
        results.appendChild(row)
      }
      if(out.length)results.classList.add("active")
      else results.classList.remove("active")
    }
    input.addEventListener("input",function(){render(input.value)})
    input.addEventListener("focus",function(){if(input.value.trim())render(input.value)})
    input.addEventListener("keydown",function(e){
      var children=results.querySelectorAll(".search-result-item")
      if(e.key==="Escape"){
        clear()
        input.blur()
        return
      }
      if(!children.length)return
      if(e.key==="ArrowDown"){
        e.preventDefault()
        activeIndex=Math.min(children.length-1,activeIndex+1)
        setActive(activeIndex)
        results.classList.add("active")
        return
      }
      if(e.key==="ArrowUp"){
        e.preventDefault()
        activeIndex=Math.max(0,activeIndex-1)
        setActive(activeIndex)
        results.classList.add("active")
        return
      }
      if(e.key==="Enter"){
        if(activeIndex>=0&&activeIndex<children.length){
          var href=children[activeIndex].dataset.href
          if(href)window.location.hash=href.slice(1)
          clear()
          input.blur()
        }
      }
    })
    document.addEventListener("mousedown",function(e){
      if(e.target===input||results.contains(e.target))return
      clear()
    })
  }
  if(document.readyState==="loading")document.addEventListener("DOMContentLoaded",setup)
  else setup()
})();</script>
 </body>
</html>