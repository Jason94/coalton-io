<!DOCTYPE html>
<html lang=en>
 <head>
  <meta charset=UTF-8>
  <title>API Documentation</title>
  <style>:root{
  --gap:28px;
  --content-gap:20px;
  --main-width:1100px;
  --bg:#ffffff;
  --fg:#1f1f1f;
  --muted:#6c6c6c;
  --border:#eeeeee;
  --code-bg:#f5f5f5;
  --code-block-bg:#1c1d21;
  --radius:8px
}
*,:before,:after{box-sizing:border-box}
html{overflow-y:scroll}
body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif;
  font-size:18px;
  line-height:1.65;
  background:var(--bg);
  color:var(--fg)
}
a{color:inherit;text-decoration:none}
a:hover{text-decoration:underline}
.main{
  position:relative;
  min-height:100vh;
  max-width:calc(var(--main-width) + var(--gap) * 2);
  margin:auto;
  padding:var(--gap)
}
.post-two-pane{width:100%}
.post-two-pane .post-content{
  display:flex;
  gap:var(--gap);
  align-items:flex-start
}
.sidebar{
  width:320px;
  position:sticky;
  top:10px;
  max-height:calc(100vh - 20px);
  overflow:auto;
  display:flex;
  flex-direction:column;
  padding-right:12px
}
.sidebar-header{
  flex-shrink:0;
  border-bottom:1px solid var(--border);
  padding:0 0 12px 0
}
.sidebar-content{padding:12px 0 0 0}
.sidebar ul{list-style:none;margin:0;padding:0}
.sidebar li{margin:0 0 6px 0}
.main-content{flex:1;min-width:0}
.main-content > h1{margin-top:0}
h1{margin:40px 0 32px;font-size:40px;line-height:1.15}
h3{margin:32px 0 16px;font-size:24px;line-height:1.2}
h4{margin:24px 0 10px;font-size:18pt;line-height:1.2}
p{margin:0 0 16px 0}
hr{margin: 30px 0;height: 2px;background: rgb(214, 214, 214);border: 0;}
code{
  font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  margin:0 4px;
  padding:4px 6px;
  font-size:.78em;
  line-height:1.5;
  background:var(--code-bg);
  border-radius:2px
}
.package-docstring,.docstring{white-space:pre-wrap}
pre{margin:16px 0}
pre code{
  display:block;
  margin:0;
  padding:10px;
  background:var(--code-block-bg);
  color:#d5d5d6;
  border-radius:var(--radius);
  overflow:auto;
  font-size:.85em
}
details{margin:12px 0 16px;border:0;padding:0}
summary{cursor:pointer;font-weight:600;padding:6px 0}
.methods-item{margin-top:5px}
.instances-list{margin:8px 0 12px 20px}
.instances-item{margin:4px 0}
.symbol-search{margin-top:10px;position:relative}
.symbol-search input{
  width:100%;
  padding:8px;
  border:1px solid #ddd;
  border-radius:4px;
  font-size:.9rem
}
.search-results{
  display:none;
  position:absolute;
  left:0;
  right:0;
  top:calc(100% + 6px);
  background:var(--bg);
  border:1px solid #ddd;
  border-radius:4px;
  max-height:320px;
  overflow:auto;
  z-index:1000
}
.search-results.active{display:block}
.search-result-item{padding:10px;border-bottom:1px solid var(--border);cursor:pointer;font-size:.85rem}
.search-result-item:last-child{border-bottom:0}
.search-result-item:hover,.search-result-item.active{background:#f8f9fa}
.search-result-symbol{font-weight:700}
.search-result-type{color:#666;font-size:.8rem;margin-left:8px}
.search-result-package{color:#888;font-size:.8rem;margin-top:4px}
@media (max-width:1050px){
  .sidebar{display:none}
  .post-two-pane .post-content{display:block}
  .main{max-width:calc(820px + var(--gap) * 2)}
}</style>
 </head>
 <body>
  <main class=main>
   <article class=post-two-pane>
    <div class=post-content><aside class=sidebar>
      <div class=sidebar-header>
       <h3 id=reference>Reference</h3>
       <div class=symbol-search>
        <input type=text id=symbol-search-input
               placeholder="Search symbols."
               autocomplete=off>
        <div class=search-results id=search-results></div></div></div>
      <div class=sidebar-content>
       <ul>
        <li><a href="#io/thread-exceptions-package"><code>IO/THREAD-EXCEPTIONS</code></a>
        <li><a href="#io/exception-package"><code>IO/EXCEPTION</code></a>
        <li><a href="#io/monad-io-package"><code>IO/MONAD-IO</code></a>
        <li><a href="#io/simple-io-package"><code>IO/SIMPLE-IO</code></a>
        <li><a href="#io/resource-package"><code>IO/RESOURCE</code></a>
        <li><a href="#io/mut-package"><code>IO/MUT</code></a>
        <li><a href="#io/term-package"><code>IO/TERM</code></a>
        <li><a href="#io/random-package"><code>IO/RANDOM</code></a>
        <li><a href="#io/thread-package"><code>IO/THREAD</code></a>
        <li><a href="#io/file-package"><code>IO/FILE</code></a>
        <li><a href="#io/unique-package"><code>IO/UNIQUE</code></a>
        <li><a href="#io/conc/future-package"><code>IO/CONC/FUTURE</code></a>
        <li><a href="#io/conc/atomic-package"><code>IO/CONC/ATOMIC</code></a>
        <li><a href="#io/conc/mvar-package"><code>IO/CONC/MVAR</code></a>
        <li><a href="#io/conc/group-package"><code>IO/CONC/GROUP</code></a>
        <li><a href="#io/conc/stm-package"><code>IO/CONC/STM</code></a>
        <li><a href="#io/conc/worker-pool-package"><code>IO/CONC/WORKER-POOL</code></a>
        <li><a href="#io/io-all-package"><code>IO/IO-ALL</code></a>
        <li><a href="#io/stubs/term-package"><code>IO/STUBS/TERM</code></a></ul></div></aside>
     <div class=main-content><h1 id="io/thread-exceptions-package">Package <code>IO/THREAD-EXCEPTIONS</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=synchronousthreadexception-type><a href="#synchronousthreadexception-type"><code>SynchronousThreadException</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L61-L64">src</a></sub></sup></sub></sup></h4><p class=docstring>Exceptions that a thread raises whenever it encounters a threading
related problem. Unlike ThreadingException, these are actual exceptions.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#synchronousthreadexception-type">SynchronousThreadException</a></code>
         <li class=instances-item><code><a href="#signalable-class">Signalable</a> <a href="#synchronousthreadexception-type">SynchronousThreadException</a></code></ul></details><h4 id=threadingexception-type><a href="#threadingexception-type"><code>ThreadingException</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L29-L32">src</a></sub></sup></sub></sup></h4><p class=docstring>Thread exception sent asynchronously between threads.
This type isn&#39;t really an exception, it&#39;s more of a message.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#threadingexception-type">ThreadingException</a></code>
         <li class=instances-item><code><a href="#signalable-class">Signalable</a> <a href="#threadingexception-type">ThreadingException</a></code></ul></details><h4 id=unmaskfinallymode-type><a href="#unmaskfinallymode-type"><code>UnmaskFinallyMode</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L75-L83">src</a></sub></sup></sub></sup></h4><p class=docstring>When a thread unmasks and calls a cleanup operation, the
thread is either:

* Still running, and will cleanup and continue
* Received a stop while it was masked, and will cleanup and then
  terminate itself.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code>
         <li class=instances-item><code><a href="#into-class">Into</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> <a href="#string-type">String</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=dynamic-is-threading-exception?-value><a href="#dynamic-is-threading-exception?-value"><code>(DYNAMIC-IS-THREADING-EXCEPTION? DYN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L39-L49">src</a></sub></sup></sub></sup></h4><code>(<a href="#dynamic-type">Dynamic</a> &rarr; <a href="#boolean-type">Boolean</a>)</code><p class=docstring>Returns true if the dynamic val is a threading exception or an
IoError containing a ThreadingException.</p><h4 id=is-threading-exception-value><a href="#is-threading-exception-value"><code>(IS-THREADING-EXCEPTION IO-ERR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L52-L59">src</a></sub></sup></sub></sup></h4><code>(<a href="#ioerror-type">IoError</a> &rarr; <a href="#boolean-type">Boolean</a>)</code><p class=docstring>Return True if IO-ERR contains a threading exception.</p></div>
      <hr><h1 id="io/exception-package">Package <code>IO/EXCEPTION</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadexception-class><a href="#monadexception-class"><code>MonadException</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L52-L76">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadexception-class">MonadException</a> :A</code><p class=docstring>A Monad that can raise and handle exceptions. IMPORTANT: Any MonadException
must catch and wrap all unhandled errors inside a wrap-io call.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>RAISE :: (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (:B :C))</code><span><br>Raise an exception.</span>
        <li class=methods-item><code>RAISE-DYNAMIC :: (<a href="#dynamic-type">Dynamic</a> &rarr; (:A :B))</code><span><br>Raise an exception wrapped in a Dynamic. Mainly useful to hand-off eexceptions&#xA;between IO instances.</span>
        <li class=methods-item><code>RERAISE :: ((:A :B) &rarr; (<a href="#unit-type">Unit</a> &rarr; (:A :C)) &rarr; (:A :B))</code><span><br>Run an operation, run a catch operation if the first operation raised,&#xA;then re-raise the exception. If the catch operation raises, that exception will&#xA;be emitted instead of the original exception.</span>
        <li class=methods-item><code>HANDLE :: <a href="#runtimerepr-class">RuntimeRepr</a> :A &rArr; ((:B :C) &rarr; (:A &rarr; (:B :C)) &rarr; (:B :C))</code><span><br>Run an operation, immediately handling if it raised an exception&#xA;that matches :e.</span>
        <li class=methods-item><code>HANDLE-ALL :: ((:A :B) &rarr; (<a href="#unit-type">Unit</a> &rarr; (:A :B)) &rarr; (:A :B))</code><span><br>Run an operation, immediately handling any exceptions raised.</span>
        <li class=methods-item><code>TRY-DYNAMIC :: ((:A :B) &rarr; (:A (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)))</code><span><br>Bring any unhandled exceptions into a Result wrapped in Dynamic.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code>(<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadio-class">MonadIo</a> :A) &rArr; <a href="#monadexception-class">MonadException</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> :A &rArr; <a href="#monadexception-class">MonadException</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> :A &rArr; <a href="#monadexception-class">MonadException</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=raise-result-dynamic-value><a href="#raise-result-dynamic-value"><code>(RAISE-RESULT-DYNAMIC OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L110-L115">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :A &rArr; ((:A (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)) &rarr; (:A :B))</code><h4 id=raise-result-value><a href="#raise-result-value"><code>(RAISE-RESULT IO-RES)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L99-L106">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadexception-class">MonadException</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) (<a href="#signalable-class">Signalable</a> :B) &rArr; ((:A (<a href="#result-type">Result</a> :B :C)) &rarr; (:A :C))</code><p class=docstring>Raise any (Err :e) into :m. Useful if (Err :e) represents any unhandleable, fatal
exception to the program.</p><h4 id=wrap-error_-value><a href="#wrap-error_-value"><code>(WRAP-ERROR_ THUNK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L119-L124">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :B &rArr; ((<a href="#unit-type">Unit</a> &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Run thunk, catching any unhandled Lisp/Coalton errors and raising
them as exceptions.</p><h4 id=try-all-value><a href="#try-all-value"><code>(TRY-ALL OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L89-L94">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadexception-class">MonadException</a> :A &rArr; ((:A :B) &rarr; (:A (<a href="#optional-type">Optional</a> :B)))</code><p class=docstring>Bring the result of OP up into an Optional. Returns None if OP
raised any exceptions.</p><h4 id=try-value><a href="#try-value"><code>(TRY OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-exception.lisp#L80-L85">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadexception-class">MonadException</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :C) &rArr; ((:A :B) &rarr; (:A (<a href="#result-type">Result</a> :C :B)))</code><p class=docstring>Bring any unhandled exceptions of type :e up into a Result.
Continues to carry any unhandeld exceptions not of type :e.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-exception-do-handle-all-macro><a href="#io-classes-monad-exception-do-handle-all-macro"><code>DO-HANDLE-ALL (OP &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for handle-all.

Example:

(do-handle-all add-three-ints
  (modify (Cons 2))
  (pure 10))
===&gt;
(handle-all add-three-ints
  (const
    (do
     (modify (cons 2))
     (pure 10))))
</p><h4
    id=io-classes-monad-exception-do-handle-macro><a href="#io-classes-monad-exception-do-handle-macro"><code>DO-HANDLE (OP (ERR-SYM) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for handle.</p><h4
    id=io-classes-monad-exception-wrap-error-macro><a href="#io-classes-monad-exception-wrap-error-macro"><code>WRAP-ERROR (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run BODY, catching any unhandled Lisp/Coalton errors and raising
them as exceptions.</p><h4
    id=io-classes-monad-exception-do-reraise-macro><a href="#io-classes-monad-exception-do-reraise-macro"><code>DO-RERAISE (OP &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Convenience macro for reraise.</p></div>
      <hr><h1 id="io/monad-io-package">Package <code>IO/MONAD-IO</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=unliftio-class><a href="#unliftio-class"><code>UnliftIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L78-L79">src</a></sub></sup></sub></sup></h4><code>(<a href="#monadio-class">MonadIo</a> :A) (<a href="#liftio-class">LiftIo</a> :B :A) &rArr; <a href="#unliftio-class">UnliftIo</a> :A :B</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WITH-RUN-IN-IO :: ((((:A :B) &rarr; (:C :B)) &rarr; (:C :D)) &rarr; (:A :D))</code></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#unliftio-class">UnliftIo</a> <a href="#io-type">IO</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code>(<a href="#baseio-class">BaseIo</a> :A) (<a href="#unliftio-class">UnliftIo</a> :B :A) &rArr; <a href="#unliftio-class">UnliftIo</a> ((<a href="#envt-type">EnvT</a> :C) :B) :A</code></ul></details><h4 id=monadio-class><a href="#monadio-class"><code>MonadIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L58-L61">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadio-class">MonadIo</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WRAP-IO_ :: ((<a href="#unit-type">Unit</a> &rarr; :A) &rarr; (:B :A))</code><span><br>Wrap a (potentially) side-effectful function in the monad.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadio-class">MonadIo</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details><h4 id=baseio-class><a href="#baseio-class"><code>BaseIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L63-L73">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#baseio-class">BaseIo</a> :A</code><p class=docstring>A &#39;base&#39; IO implementation, which can be run to execute some
(potentially side-effectful) operation.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>RUN! :: ((:A :B) &rarr; :B)</code><span><br>Run a (potentially) side-effectful operation. Throws any unhandled&#xA;exceptions.</span>
        <li class=methods-item><code>RUN-HANDLED! :: ((:A :B) &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B))</code><span><br>Run a (potentially) side-effectful operation. Returns any unhandled&#xA;exceptions as an (Err e).</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> <a href="#io-type">IO</a></code></ul></details><h4 id=liftio-class><a href="#liftio-class"><code>LiftIo</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L75-L76">src</a></sub></sup></sub></sup></h4><code>(<a href="#monad-class">Monad</a> :A) (<a href="#baseio-class">BaseIo</a> :B) &rArr; <a href="#liftio-class">LiftIo</a> :B :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>LIFT-IO :: <a href="#baseio-class">BaseIo</a> :A &rArr; ((:A :B) &rarr; (:C :B))</code></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A (<a href="#loopt-type">LoopT</a> :B)</code>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A ((<a href="#envt-type">EnvT</a> :C) :B)</code>
         <li class=instances-item><code><a href="#liftio-class">LiftIo</a> :A :B &rArr; <a href="#liftio-class">LiftIo</a> :A ((<a href="#statet-type">StateT</a> :C) :B)</code>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> :A &rArr; <a href="#liftio-class">LiftIo</a> :A :A</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=map-into-io-value><a href="#map-into-io-value"><code>(MAP-INTO-IO ITR A-&gt;RB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L188-L198">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#intoiterator-class">IntoIterator</a> :B :C) &rArr; (:B &rarr; (:C &rarr; (:D :E)) &rarr; (:F (<a href="#list-type">List</a> :E)))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator
and return the results. If you&#39;re having inference issues, try map-into-io_</p><h4 id=foreach-io-value><a href="#foreach-io-value"><code>(FOREACH-IO COLL A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L202-L222">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#intoiterator-class">IntoIterator</a> :B :C) &rArr; (:B &rarr; ((<a href="#cell-type">Cell</a> :C) &rarr; (:D :E)) &rarr; (:F <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
The next element of the iterator is passed into the operation via a cell.
If your effect can be run in simple-io/IO, the version in that package will be
faster!</p><h4 id=times-io-value><a href="#times-io-value"><code>(TIMES-IO N IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io.lisp#L225-L234">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#unliftio-class">UnliftIo</a> :B :A) (<a href="#liftto-class">LiftTo</a> :B :D) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:B :C) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform an IO operation N times. If the effect can be run in
simple-io/IO, the version in that package will be faster!</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-classes-monad-io-do-times-io-macro><a href="#io-classes-monad-io-do-times-io-macro"><code>DO-TIMES-IO (N &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform an IO operation N times. If the effect can be run in
simple-io/IO, the version in that package will be faster!</p><h4
    id=io-classes-monad-io-derive-lift-io-macro><a href="#io-classes-monad-io-derive-lift-io-macro"><code>DERIVE-LIFT-IO (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of LiftIo for a monad transformer.

Example:
  (derive-lift-io :m (e:EnvT :e :m))</p><h4
    id=io-classes-monad-io-do-foreach-io-macro><a href="#io-classes-monad-io-do-foreach-io-macro"><code>DO-FOREACH-IO ((VAR-SYM INTO-ITR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
VAR-SYM is bound to the value of the element in the iterator. If your effect can
be run in simple-io/IO, the version in that package will be faster!</p><h4
    id=io-classes-monad-io-derive-monad-io-macro><a href="#io-classes-monad-io-derive-monad-io-macro"><code>DERIVE-MONAD-IO (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIo for a monad transformer.

Example:
  (derive-monad-io :m (st:StateT :s :m))</p><h4 id=io-classes-monad-io-run-as!-macro><a href="#io-classes-monad-io-run-as!-macro"><code>RUN-AS! (M-TYPE M-OP)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run M-OP using the concrete RunIo M-TYPE. Useful for situations where
you want to create a generic MonadIo operation and immediately run it,
so the compiler can&#39;t infer the type of the actual monad you want to use.

Example:
  (run-as! (IO Unit) (pure Unit))

NOTE: Unfortunately, there seems to be a type inference bug that requires
putting in the full type of M-OP, not just (IO :a).
</p><h4 id=io-classes-monad-io-wrap-io-macro><a href="#io-classes-monad-io-wrap-io-macro"><code>WRAP-IO (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Wrap the execution of BODY in the IO monad.
Supports any MonadIo instance.

Example:
  (wrap-io
    (lisp :a (str)
      (cl:print str))</p><h4
    id=io-classes-monad-io-do-map-into-io-macro><a href="#io-classes-monad-io-do-map-into-io-macro"><code>DO-MAP-INTO-IO ((VAR LST) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/simple-io-package">Package <code>IO/SIMPLE-IO</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=io-type><a href="#io-type"><code>IO</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L79-L80">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#applicative-class">Applicative</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#baseio-class">BaseIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#functor-class">Functor</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadexception-class">MonadException</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#io-type">IO</a> :A)</code>
         <li class=instances-item><code><a href="#unliftio-class">UnliftIo</a> <a href="#io-type">IO</a> <a href="#io-type">IO</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=raise-dynamic-io-value><a href="#raise-dynamic-io-value"><code>(RAISE-DYNAMIC-IO DYN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L174-L176">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#dynamic-type">Dynamic</a> &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=with-run-in-io_-value><a href="#with-run-in-io_-value"><code>(WITH-RUN-IN-IO_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L274-L277">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#unliftio-class">UnliftIo</a> :A <a href="#io-type">IO</a> &rArr; ((((:A :B) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:A :C))</code><p class=docstring>`with-run-in-io`, but pegged to the simple-io implementation. Useful when you
need to unlift, run, then immediately re-run a function. See, e.g., io-file:with-open-file%.</p><h4 id=try-dynamic-io-value><a href="#try-dynamic-io-value"><code>(TRY-DYNAMIC-IO IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L234-L248">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#io-type">IO</a> (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :A)))</code><h4 id=handle-all-io-value><a href="#handle-all-io-value"><code>(HANDLE-ALL-IO IO-OP HANDLE-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L218-L230">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (<a href="#io-type">IO</a> :A))</code><p class=docstring>Run IO-OP, and run HANDLE-OP to handle exceptions of any type thrown by IO-OP.</p><h4 id=map-into-io_-value><a href="#map-into-io_-value"><code>(MAP-INTO-IO_ ITR A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L299-L313">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :D) (<a href="#intoiterator-class">IntoIterator</a> :A :B) &rArr; (:A &rarr; (:B &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D (<a href="#list-type">List</a> :C)))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator
and return the results. More efficient than map-into-io, if you can run your
effect in a BaseIo.</p><h4 id=foreach-io_-value><a href="#foreach-io_-value"><code>(FOREACH-IO_ COLL A-&gt;MB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L317-L335">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :D) (<a href="#intoiterator-class">IntoIterator</a> :A :B) &rArr; (:A &rarr; ((<a href="#cell-type">Cell</a> :B) &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
More efficient than foreach-io, if your effect can run in IO. The next element of the
iterator is passed into the operation via a cell.</p><h4 id=reraise-io-value><a href="#reraise-io-value"><code>(RERAISE-IO OP CATCH-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L184-L193">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. ((<a href="#io-type">IO</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=times-io_-value><a href="#times-io_-value"><code>(TIMES-IO_ N IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L338-L344">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :B &rArr; (<a href="#ufix-type">UFix</a> &rarr; (<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Efficiently perform an IO operation N times.</p><h4 id=raise-io_-value><a href="#raise-io_-value"><code>(RAISE-IO_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L180-L180">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (<a href="#io-type">IO</a> <a href="#unit-type">Unit</a>))</code><h4 id=handle-io-value><a href="#handle-io-value"><code>(HANDLE-IO IO-OP HANDLE-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L197-L214">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtimerepr-class">RuntimeRepr</a> :B &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (<a href="#io-type">IO</a> :A))</code><h4 id=raise-io-value><a href="#raise-io-value"><code>(RAISE-IO E)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L168-L170">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#signalable-class">Signalable</a> :A) &rArr; (:A &rarr; (<a href="#io-type">IO</a> :B))</code><h4 id=run-io!-value><a href="#run-io!-value"><code>(RUN-IO! IO-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/simple-io.lisp#L116-L128">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#io-type">IO</a> :A) &rarr; :A)</code><p class=docstring>Top-level run-io! that raises any unhandled exceptions.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-io-impl-simple-io-do-map-into-io_-macro><a href="#io-io-impl-simple-io-do-map-into-io_-macro"><code>DO-MAP-INTO-IO_ ((VAR LST) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-simple-io-do-times-io_-macro><a href="#io-io-impl-simple-io-do-times-io_-macro"><code>DO-TIMES-IO_ (N &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform an IO operation N times.</p><h4
    id=io-io-impl-simple-io-do-foreach-io_-macro><a href="#io-io-impl-simple-io-do-foreach-io_-macro"><code>DO-FOREACH-IO_ ((VAR-SYM INTO-ITR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Efficiently perform a monadic operation for each element of an iterator.
More efficient than foreach-io, if your effect can run in IO. VAR-SYM is bound
to the value of the element in the iterator.</p></div>
      <hr><h1 id="io/resource-package">Package <code>IO/RESOURCE</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=exitcase-type><a href="#exitcase-type"><code>ExitCase</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L58-L61">src</a></sub></sup></sub></sup></h4><p class=docstring>Signals the exit condition for an effectful computation using some resource.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> :A &rArr; <a href="#eq-class">Eq</a> (<a href="#exitcase-type">ExitCase</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#exitcase-type">ExitCase</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=bracket-io-masked_-value><a href="#bracket-io-masked_-value"><code>(BRACKET-IO-MASKED_ ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L154-L166">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) &rArr; ((:C :D) &rarr; (:D &rarr; (:C :E)) &rarr; (:D &rarr; (:C :F)) &rarr; (:C :F))</code><p class=docstring>Acquire a resource, run a computation with it, and release it. Guarantees that RELEASE-OP will
run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception, it will be re-raised after the
resource cleans up. If ACQUIRE-OP or RELEASE-OP raise an exception, then release is not guaranteed.
Masks the thread during the entire operation, including the computation.</p><h4 id=bracket-io-masked-value><a href="#bracket-io-masked-value"><code>(BRACKET-IO-MASKED ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L107-L124">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#runtimerepr-class">RuntimeRepr</a> :E) (<a href="#signalable-class">Signalable</a> :E) &rArr; ((:C :D) &rarr; (:D &rarr; (<a href="#exitcase-type">ExitCase</a> :E) &rarr; (:C :F)) &rarr; (:D &rarr; (:C :G)) &rarr; (:C :G))</code><p class=docstring>WARNING: BRACKET-IO-MASKED will *only* cleanup if the raised exception matches :e, or if the
computation succeedes. To guarantee cleanup after any exception, use BRACKET-IO-MASKED_

Acquire a resource, run a computation with it, and release it. Guarantees that RELEASE-OP will run
if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception, it will be re-raised after the
resource cleans up. If ACQUIRE-OP or RELEASE-OP raise an exception, then release is not guaranteed.
Masks the thread during the entire operation, including the computation.</p><h4 id=bracket-io_-value><a href="#bracket-io_-value"><code>(BRACKET-IO_ ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L131-L147">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) &rArr; ((:C :D) &rarr; (:D &rarr; (:C :E)) &rarr; (:D &rarr; (:C :F)) &rarr; (:C :F))</code><p class=docstring>Acquire a resource, run a computation with it, and release it. Guarantees that
RELEASE-OP will run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception,
it will be re-raised after the resource cleans up. If ACQUIRE-OP or RELEASE-OP raise
an exception, then release is not guaranteed.

Masks the thread during resource acquisition and release. The computation is not
masked, but if another thread stops this one during the computation then the resource
will release before the thread is stopped.</p><h4 id=bracket-io-value><a href="#bracket-io-value"><code>(BRACKET-IO ACQUIRE-OP RELEASE-OP COMPUTATION-OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L76-L100">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#runtimerepr-class">RuntimeRepr</a> :E) (<a href="#signalable-class">Signalable</a> :E) &rArr; ((:C :D) &rarr; (:D &rarr; (<a href="#exitcase-type">ExitCase</a> :E) &rarr; (:C :F)) &rarr; (:D &rarr; (:C :G)) &rarr; (:C :G))</code><p class=docstring>WARNING: BRACKET-IO will *only* cleanup if the raised exception matches :e,
or if the computation succeedes. To guarantee cleanup after any exception,
use BRACKET-IO_

Acquire a resource, run a computation with it, and release it. Guarantees that
RELEASE-OP will run if ACQUIRE-OP completes. If COMPUTATION-OP raises an exception,
it will be re-raised after the resource cleans up. If ACQUIRE-OP or RELEASE-OP raise
an exception, then release is not guaranteed.

Concurrent:
- Masks the thread during resource acquisition and release.
- The computation is not masked, and if another thread stops this one during the
  computation then the resource the resource will not be released.</p><h4 id=with-mask-value><a href="#with-mask-value"><code>(WITH-MASK OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-resource.lisp#L33-L44">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; ((:C :D) &rarr; (:C :D))</code><p class=docstring>Mask the current thread while running OP, automatically unmasking
afterward.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-resource-do-with-mask-macro><a href="#io-resource-do-with-mask-macro"><code>DO-WITH-MASK (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Evaluate BODY with the current thread masked, automatically unmasking
afterward.</p></div>
      <hr><h1 id="io/mut-package">Package <code>IO/MUT</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=var-type><a href="#var-type"><code>Var</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-var.lisp#L33-L34">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> (<a href="#cell-type">Cell</a> :A) &rArr; <a href="#eq-class">Eq</a> (<a href="#var-type">Var</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#var-type">Var</a> :A)</code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiovar-class><a href="#monadiovar-class"><code>MonadIoVar</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-var.lisp#L36-L48">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>NEW-VAR :: (:A &rarr; (:B (<a href="#var-type">Var</a> :A)))</code><span><br>Create a new variable with an initial value.</span>
        <li class=methods-item><code>READ :: ((<a href="#var-type">Var</a> :A) &rarr; (:B :A))</code><span><br>Read the current value stored in a variable.</span>
        <li class=methods-item><code>WRITE :: ((<a href="#var-type">Var</a> :A) &rarr; :A &rarr; (:B :A))</code><span><br>Set the value in a variable and return the old value.</span>
        <li class=methods-item><code>MODIFY :: ((<a href="#var-type">Var</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><span><br>Modify the value in a variable by applying F, and return the old value.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiovar-class">MonadIoVar</a> :A &rArr; <a href="#monadiovar-class">MonadIoVar</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=modify-value><a href="#modify-value"><code>(MODIFY FS-&gt;S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/monad/state.lisp#L56-L59">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((:A &rarr; :A) &rarr; (<a href="#st-type">ST</a> :A <a href="#unit-type">Unit</a>))</code><p class=docstring>Modify the state in a StatefulComputation, discarding the old state.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY ATM F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L65-L73">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadio-class">MonadIo</a> :B) (<a href="#monadexception-class">MonadException</a> :B) &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Atomically modify `atm` by applying `f` and return the new value. `f` must be a pure
function. If `f` throws an error, `atm` will be unchanged and the error will be handleable
via `MonadException`.

Concurrent:
  - WARNING: `f` will be retried each time the calling thread loses the race to update
    `atm`, so `f` must be pure.</p><h4 id=write-value><a href="#write-value"><code>(WRITE ATM VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L59-L61">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; :A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Atomically write a new value to `atm`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L53-L55">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:B :A))</code><p class=docstring>Atomically read the value from `atm`.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY HM KEY F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/hashmap.lisp#L626-L628">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#hash-class">Hash</a> :A &rArr; ((<a href="#hashmap-type">HashMap</a> :A :B) &rarr; :A &rarr; (:B &rarr; :B) &rarr; (<a href="#hashmap-type">HashMap</a> :A :B))</code><p class=docstring>Modify the value at KEY with F. Returns the modified `HashMap`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-impl/atomics.lisp#L84-L87">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#atomic-type">Atomic</a> :A) &rarr; :A)</code><p class=docstring>Read the value of an atomic cell `atm`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATOMIC)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/atomic.lisp#L47-L50">src</a></sub></sup></sub></sup></h4><code>(<a href="#atomicinteger-type">AtomicInteger</a> &rarr; <a href="#u64-type">U64</a>)</code><p class=docstring>Returns the current value of `atomic&#39;.</p><h4 id=read-value><a href="#read-value"><code>(READ MUTEX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/mutex.lisp#L27-L31">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#mutex-type">Mutex</a> :A) &rarr; :A)</code><p class=docstring>Access the value held in a Mutex.</p><h4 id=read-value><a href="#read-value"><code>(READ CEL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/cell.lisp#L53-L56">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#cell-type">Cell</a> :A) &rarr; :A)</code><p class=docstring>Read the value of a mutable cell `cel`.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-var-derive-monad-var-macro><a href="#io-classes-monad-io-var-derive-monad-var-macro"><code>DERIVE-MONAD-VAR (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoVar for a monad transformer.

Example:
  (derive-monad-var :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-mut-implement-monad-io-var-macro><a href="#io-gen-impl-mut-implement-monad-io-var-macro"><code>IMPLEMENT-MONAD-IO-VAR (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/term-package">Package <code>IO/TERM</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadioterm-class><a href="#monadioterm-class"><code>MonadIoTerm</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-term.lisp#L24-L33">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>WRITE :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><span><br>Write a string to standard output.</span>
        <li class=methods-item><code>WRITE-LINE :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><span><br>Write a string to standard output followed by a newline.</span>
        <li class=methods-item><code>READ-LINE :: (:A <a href="#string-type">String</a>)</code><span><br>Read a line from standard input.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadioterm-class">MonadIoTerm</a> :A &rArr; <a href="#monadioterm-class">MonadIoTerm</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=write-value><a href="#write-value"><code>(WRITE ATM VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L59-L61">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; :A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Atomically write a new value to `atm`.</p><h4 id=write-line-value><a href="#write-line-value"><code>(WRITE-LINE STREAM S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L622-L625">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Writes a string with an appended newline to a filestream of type Char.</p><h4 id=read-line-value><a href="#read-line-value"><code>(READ-LINE STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L454-L459">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>))</code><p class=docstring>Reads a line of characters from a FileStream.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-term-derive-monad-io-term-macro><a href="#io-classes-monad-io-term-derive-monad-io-term-macro"><code>DERIVE-MONAD-IO-TERM (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoTerm for a monad transformer.

Example:
  (derive-monad-io-term :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-term-implement-monad-io-term-macro><a href="#io-gen-impl-term-implement-monad-io-term-macro"><code>IMPLEMENT-MONAD-IO-TERM (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/random-package">Package <code>IO/RANDOM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=randomstate-type><a href="#randomstate-type"><code>RandomState</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L45-L45">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#randomstate-type">RandomState</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiorandom-class><a href="#monadiorandom-class"><code>MonadIoRandom</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L47-L65">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>MAKE-RANDOM-STATE :: (:A <a href="#randomstate-type">RandomState</a>)</code><span><br>Create a fresh random state.</span>
        <li class=methods-item><code>COPY-RANDOM-STATE :: (<a href="#randomstate-type">RandomState</a> &rarr; (:A <a href="#randomstate-type">RandomState</a>))</code><span><br>Create a copy of another random state, starting at the same seed.</span>
        <li class=methods-item><code>GET-CURRENT-RANDOM-STATE :: (:A <a href="#randomstate-type">RandomState</a>)</code><span><br>Get the current thread&apos;s random state.</span>
        <li class=methods-item><code>SET-CURRENT-RANDOM-STATE :: (<a href="#randomstate-type">RandomState</a> &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Set the current thread&apos;s random state.</span>
        <li class=methods-item><code>RANDOM :: <a href="#randomlimit-class">RandomLimit</a> :A &rArr; (<a href="#randomstate-type">RandomState</a> &rarr; :A &rarr; (:B :A))</code><span><br>Generate a random value less than LIMIT using the given random state.</span>
        <li class=methods-item><code>RANDOM_ :: <a href="#randomlimit-class">RandomLimit</a> :A &rArr; (:A &rarr; (:B :A))</code><span><br>Generate a random value less than LIMIT using the current random state.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiorandom-class">MonadIoRandom</a> :A &rArr; <a href="#monadiorandom-class">MonadIoRandom</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details><h4 id=randomlimit-class><a href="#randomlimit-class"><code>RandomLimit</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L36-L37">src</a></sub></sup></sub></sup></h4><code><a href="#num-class">Num</a> :A &rArr; <a href="#randomlimit-class">RandomLimit</a> :A</code><p class=docstring>A number that can be used to bound a random number value.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#f64-type">F64</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#f32-type">F32</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#integer-type">Integer</a></code>
         <li class=instances-item><code><a href="#randomlimit-class">RandomLimit</a> <a href="#ufix-type">UFix</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=random-elt#_-value><a href="#random-elt#_-value"><code>(RANDOM-ELT#_ LST)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L96-L99">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadiorandom-class">MonadIoRandom</a> :B &rArr; ((<a href="#list-type">List</a> :A) &rarr; (:B :A))</code><p class=docstring>Get a random element from LST. Errors if LST is empty.</p><h4 id=random-elt_-value><a href="#random-elt_-value"><code>(RANDOM-ELT_ LST)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L81-L87">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadiorandom-class">MonadIoRandom</a> :B &rArr; ((<a href="#list-type">List</a> :A) &rarr; (:B (<a href="#optional-type">Optional</a> :A)))</code><p class=docstring>Get a random element from LST. Returns NONE if LST is empty.</p><h4 id=random-elt#-value><a href="#random-elt#-value"><code>(RANDOM-ELT# RS LST)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L90-L93">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadiorandom-class">MonadIoRandom</a> :B &rArr; (<a href="#randomstate-type">RandomState</a> &rarr; (<a href="#list-type">List</a> :A) &rarr; (:B :A))</code><p class=docstring>Get a random element from LST. Errors if LST is empty.</p><h4 id=random-elt-value><a href="#random-elt-value"><code>(RANDOM-ELT RS LST)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-random.lisp#L72-L78">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadiorandom-class">MonadIoRandom</a> :B &rArr; (<a href="#randomstate-type">RandomState</a> &rarr; (<a href="#list-type">List</a> :A) &rarr; (:B (<a href="#optional-type">Optional</a> :A)))</code><p class=docstring>Get a random element from LST. Returns NONE if LST is empty.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-random-derive-monad-io-random-macro><a href="#io-classes-monad-io-random-derive-monad-io-random-macro"><code>DERIVE-MONAD-IO-RANDOM (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoRandom for a monad transformer.

Example:
  (derive-monad-io-random :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-random-implement-monad-io-random-macro><a href="#io-gen-impl-random-implement-monad-io-random-macro"><code>IMPLEMENT-MONAD-IO-RANDOM (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/thread-package">Package <code>IO/THREAD</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=unmaskfinallymode-type><a href="#unmaskfinallymode-type"><code>UnmaskFinallyMode</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-exceptions.lisp#L75-L83">src</a></sub></sup></sub></sup></h4><p class=docstring>When a thread unmasks and calls a cleanup operation, the
thread is either:

* Still running, and will cleanup and continue
* Received a stop while it was masked, and will cleanup and then
  terminate itself.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code>
         <li class=instances-item><code><a href="#into-class">Into</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> <a href="#string-type">String</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unmaskfinallymode-type">UnmaskFinallyMode</a></code></ul></details></div>
      <hr><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=iothread-type><a href="#iothread-type"><code>IoThread</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-impl/runtime.lisp#L109-L111">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> <a href="#iothread-type">IoThread</a> <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#iothread-type">IoThread</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#runtime-class">Runtime</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#iothread-type">IoThread</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiothread-class><a href="#monadiothread-class"><code>MonadIoThread</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L197-L203">src</a></sub></sup></sub></sup></h4><code>(<a href="#monadio-class">MonadIo</a> :A) (<a href="#runtime-class">Runtime</a> :B :C) &rArr; <a href="#monadiothread-class">MonadIoThread</a> :B :C :A</code><p class=docstring>A MonadIo which can spawn :t&#39;s. Other :t&#39;s error
separately. A spawned :t erroring will not cause the parent
:t to fail. :t can be any &#39;thread-like&#39; object, depending on the
underlying implementation - system threads, software-managed green
threads, etc.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B (<a href="#loopt-type">LoopT</a> :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#envt-type">EnvT</a> :D) :C)</code>
         <li class=instances-item><code><a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; <a href="#monadiothread-class">MonadIoThread</a> :A :B ((<a href="#statet-type">StateT</a> :D) :C)</code></ul></details><h4 id=concurrent-class><a href="#concurrent-class"><code>Concurrent</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L152-L185">src</a></sub></sup></sub></sup></h4><code><a href="#concurrent-class">Concurrent</a> :A :B</code><p class=docstring>A Concurrent has thread-like semantics. It can be stopped, masked, unmasked, and await-ed.
Concurrents don&#39;t have a uniform fork function, becasue they require different initialization
input.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>STOP :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Stop a Concurrent. If the Concurrent has already stopped, does nothing. If the Concurrent is&#xA;masked, this will pend a stop on the Concurrent. When/if the Concurrent becomes completely unmaksed,&#xA;it will stop iself. Regardless of whether the target Concurrent is masked, STOP does not block or&#xA;wait for the target to complete.</span>
        <li class=methods-item><code>AWAIT :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A :E))</code><span><br>Block the current thread until the target Concurrent is completed, and retrieve its value.&#xA;Re-raises if the target Concurrent raised an unhandled exception</span>
        <li class=methods-item><code>MASK :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Mask the Concurrent so it can&apos;t be stopped.</span>
        <li class=methods-item><code>UNMASK :: (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (:D &rarr; (:A <a href="#unit-type">Unit</a>))</code><span><br>Unmask the Concurrent so it can be stopped. Unmask respects nested masks - if the&#xA;Concurrent has been masked N times, it can only be stopped after being unmasked N times. When the&#xA;Concurrent unmasks, if there are any pending stops, it will immediately stop itself.</span>
        <li class=methods-item><code>UNMASK-FINALLY :: (<a href="#unliftio-class">UnliftIo</a> :A :B) (<a href="#liftto-class">LiftTo</a> :A :C) (<a href="#monadiothread-class">MonadIoThread</a> :D :E :A) (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadiothread-class">MonadIoThread</a> :D :E :C) &rArr; (:F &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:A :G)) &rarr; (:C <a href="#unit-type">Unit</a>))</code><span><br>Unmask the thread, run the provided action, and then honor any pending stop for that&#xA;thread after the action finishes.&#xA;&#xA;Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be&#xA;inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the&#xA;callback should leave any resources in a valid state. An example of a valid callback: closing a log&#xA;file if the thread is stopped, or closing the log file with a final message if the thread is&#xA;continuing.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A <a href="#unit-type">Unit</a>) (<a href="#list-type">List</a> <a href="#unit-type">Unit</a>) &rArr; <a href="#concurrent-class">Concurrent</a> ((<a href="#workerpool-type">WorkerPool</a> :B) :A) <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> :A :B &rArr; <a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B) (<a href="#list-type">List</a> :B)</code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#future-type">Future</a> :A) :A</code>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> <a href="#iothread-type">IoThread</a> <a href="#unit-type">Unit</a></code></ul></details><h4 id=runtime-class><a href="#runtime-class"><code>Runtime</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L78-L138">src</a></sub></sup></sub></sup></h4><code><a href="#runtime-class">Runtime</a> :A :B</code><p class=docstring>This class doesn&#39;t represent data, but the type tells a Concurrent and
a MonadIoThread how to hook into the native threading implementations that
a runtime provides.  A runtime has a &#39;base&#39; concurrent, which is the underlying
thread/fiber/etc. that the runtime produces to run concurrently. All other
Concurrents are built by composing on the base concurrent somehow.

Runtime is a low-level type that operates inside the normal MonadIo layer.
It should not be used by normal application code. Its two main purposes are:
(1) to make MonadIoThread generic over the type of thread it forks, and
(2) to build low-level, efficient concurrency tools that are generic
over the underlying thread type.</p><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>CURRENT-THREAD! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B)</code><span><br>Get a handle for the current thread.</span>
        <li class=methods-item><code>SLEEP! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Sleep the current thread for MSECS milliseconds.</span>
        <li class=methods-item><code>FORK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)) &rarr; :C)</code><span><br>Spawn a new thread, which starts running immediately.&#xA;Returns the handle to the thread.</span>
        <li class=methods-item><code>FORK-THROW! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; (<a href="#unit-type">Unit</a> &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> :B)) &rarr; :C)</code><span><br>Spawn a new thread, which starts running immediately. Returns&#xA;the handle to the thread. If the thread raises an unhandled exception,&#xA;throws immediately. The underlying system determines the result of the&#xA;throw, but it could include terminating the whole program.</span>
        <li class=methods-item><code>JOIN! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; (<a href="#result-type">Result</a> <a href="#dynamic-type">Dynamic</a> <a href="#unit-type">Unit</a>))</code><span><br>Block the current thread until the target thread is completed.&#xA;Does not a retrieve value. Raises an exception if the target thread&#xA;raised an unhandled exception, wrapping the target thread&apos;s raised&#xA;exception. JOIN! is the lowest level operation to block on another&#xA;thread&apos;s termination, and most code should use AWAIT instead.</span>
        <li class=methods-item><code>STOP! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Stop a :t. If the thread has already stopped, does nothing.&#xA;If the :t is masked, this will pend a stop on the :t. When/if&#xA;the :t becomes completely unmaksed, it will stop iself. Regardless&#xA;of whether the target :t is masked, STOP does not block or wait for&#xA;the target thread to complete.</span>
        <li class=methods-item><code>MASK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Mask the thread so it can&apos;t be stopped.</span>
        <li class=methods-item><code>UNMASK! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Unmask the thread so it can be stopped. Unmask respects&#xA;nested masks - if the thread has been masked N times, it can only be&#xA;stopped after being unmasked N times. When the thread unmasks, if&#xA;there are any pending stops, it will immediately be stopped.</span>
        <li class=methods-item><code>UNMASK-FINALLY! :: ((<a href="#proxy-type">Proxy</a> :A) &rarr; :B &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; :C) &rarr; <a href="#unit-type">Unit</a>)</code><span><br>Unmask the thread, run the provided action, and then honor any pending stop for that&#xA;thread after the action finishes.&#xA;&#xA;Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be&#xA;inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the&#xA;callback should leave any resources in a valid state. An example of a valid callback: closing a log&#xA;file if the thread is stopped, or closing the log file with a final message if the thread is&#xA;continuing.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtime-class">Runtime</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a></code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=await-value><a href="#await-value"><code>(AWAIT CV LOCK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/condition-variable.lisp#L26-L34">src</a></sub></sup></sub></sup></h4><code>(<a href="#conditionvariable-type">ConditionVariable</a> &rarr; <a href="#lock-type">Lock</a> &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Atomically release `lock&#39; and enqueue the calling thread waiting for `cv&#39;.
The thread will resume when another thread has notified it using `notify-cv&#39;;
it may also resume if interrupted by some external event or in other
implementation-dependent circumstances: the caller must always test on waking
that there is threading to be done, instead of assuming that it can go ahead.</p><h4 id=unmask-current-thread-finally-value><a href="#unmask-current-thread-finally-value"><code>(UNMASK-CURRENT-THREAD-FINALLY OP-FINALLY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L398-L414">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :E) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) &rArr; ((<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:D <a href="#unit-type">Unit</a>)) &rarr; (:E <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the current thread, run the provided action, and then honor any
 pending stop for that thread after the action finishes.

Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be
inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the
callback should leave any resources in a valid state. An example of a valid callback: closing a log
file if the thread is stopped, or closing the log file with a final message if the thread is
continuing.</p><h4 id=unmask-thread-finally-value><a href="#unmask-thread-finally-value"><code>(UNMASK-THREAD-FINALLY THREAD OP-FINALLY)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L379-L393">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) &rArr; (:C &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (:D :E)) &rarr; (:F <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the thread, run the provided action, and then honor any
 pending stop for that thread after the action finishes.

Warning: There is a very small chance that the UnmaskFinallyMode passed to the callback could be
inconsistent with whether the Concurrent is ultimately stopped. Regardless of the input, the
callback should leave any resources in a valid state. An example of a valid callback: closing a log
file if the thread is stopped, or closing the log file with a final message if the thread is
continuing.</p><h4 id=unmask-current-thread-value><a href="#unmask-current-thread-value"><code>UNMASK-CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L365-L374">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C <a href="#unit-type">Unit</a>)</code><p class=docstring>Unmask the current thread so it can be stopped. Unmask respects
nested masks - if the thread has been masked N times, it can only be
stopped after being unmasked N times.</p><h4 id=mask-current-thread-value><a href="#mask-current-thread-value"><code>MASK-CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L345-L353">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C <a href="#unit-type">Unit</a>)</code><p class=docstring>Mask the current thread so it can&#39;t be stopped.</p><h4 id=fork-thread-throw-value><a href="#fork-thread-throw-value"><code>(FORK-THREAD-THROW OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L288-L299">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :C :A) (<a href="#liftto-class">LiftTo</a> :C :E) (<a href="#monadiothread-class">MonadIoThread</a> :B :F :C) &rArr; ((:C :D) &rarr; (:E :F))</code><p class=docstring>Spawn a new thread, which starts running immediately. Returns
the handle to the thread. If the thread raises an unhandled exception,
throws immediately. The underlying system determines the result of the
throw, but it could include terminating the whole program.</p><h4 id=unmask-current!-value><a href="#unmask-current!-value"><code>(UNMASK-CURRENT! RT-PRX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L148-L150">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtime-class">Runtime</a> :B :A &rArr; ((<a href="#proxy-type">Proxy</a> :B) &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Unmask the current thread.</p><h4 id=current-thread-value><a href="#current-thread-value"><code>CURRENT-THREAD</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L333-L335">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :C :B &rArr; (:B :C)</code><p class=docstring>Get the current thread.</p><h4 id=unmask-thread-value><a href="#unmask-thread-value"><code>(UNMASK-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L357-L361">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Unmask the thread so it can be stopped. Unmask respects
nested masks - if the thread has been masked N times, it can only be
stopped after being unmasked N times.</p><h4 id=mask-current!-value><a href="#mask-current!-value"><code>(MASK-CURRENT! RT-PRX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L142-L144">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#runtime-class">Runtime</a> :B :A &rArr; ((<a href="#proxy-type">Proxy</a> :B) &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Mask the current thread.</p><h4 id=stop-thread-value><a href="#stop-thread-value"><code>(STOP-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L321-L323">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Stop a thread. If the thread has already stopped, does nothing.</p><h4 id=mask-thread-value><a href="#mask-thread-value"><code>(MASK-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L339-L341">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Mask the thread so it can&#39;t be stopped.</p><h4 id=join-thread-value><a href="#join-thread-value"><code>(JOIN-THREAD THREAD)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L303-L317">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (:B &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Block the current thread until the target thread is completed.
Does not a retrieve value. Raises an exception if the target thread
raised an unhandled exception, wrapping the target thread&#39;s raised
exception. JOIN-THREAD is the lowest level operation to block on another
thread&#39;s termination.</p><h4 id=fork-thread-value><a href="#fork-thread-value"><code>(FORK-THREAD OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L268-L283">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :C :A) (<a href="#liftto-class">LiftTo</a> :C :E) (<a href="#monadiothread-class">MonadIoThread</a> :B :F :C) &rArr; ((:C :D) &rarr; (:E :F))</code><p class=docstring>Spawn a new thread, which starts running immediately. Returns
the handle to the thread. If the thread raises an unhandled exception,
it will be logged to *ERROR-OUTPUT* and swallowed, until/if the thread
is joined.

This version can accept
any underlying BaseIo, which can be useful, but causes inference
issues in some cases.</p><h4 id=sleep-value><a href="#sleep-value"><code>(SLEEP MSEC)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-thread.lisp#L327-L329">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:C <a href="#unit-type">Unit</a>))</code><p class=docstring>Sleep the current thread for MSECS milliseconds.</p><h4 id=await-value><a href="#await-value"><code>(AWAIT SEM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/semaphore.lisp#L31-L36">src</a></sub></sup></sub></sup></h4><code>(<a href="#semaphore-type">Semaphore</a> &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Decrement the count of `sem&#39; by 1 if the count is larger than zero.
If the count is zero, blocks until `sem&#39; can be decremented.</p><h4 id=await-value><a href="#await-value"><code>(AWAIT BARRIER)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/barrier.lisp#L42-L47">src</a></sub></sup></sub></sup></h4><code>(<a href="#barrier-type">Barrier</a> &rarr; <a href="#unit-type">Unit</a>)</code><h4 id=current-thread-value><a href="#current-thread-value"><code>(CURRENT-THREAD _)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/thread.lisp#L48-L51">src</a></sub></sup></sub></sup></h4><code>(<a href="#unit-type">Unit</a> &rarr; <a href="#lispthread-type">LispThread</a>)</code><p class=docstring>Returns the thread object representing the calling thread.</p><h4 id=sleep-value><a href="#sleep-value"><code>(SLEEP N)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/system.lisp#L57-L66">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#rational-class">Rational</a> :A &rArr; (:A &rarr; <a href="#unit-type">Unit</a>)</code><p class=docstring>Sleep for `n` seconds, where `n` can be of any type with an instance of `Rational`.

Sleep uses type class `Rational`&#39;s `best-approx` instead of `Real`&#39;s `real-approx` because it handles the approximation without arbitrary precision. The only `Real` type excluded by this decision is `CReal`.</p><h4 id=write-line-sync-value><a href="#write-line-sync-value"><code>(WRITE-LINE-SYNC MSG)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-thread.lisp#L25-L28">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#into-class">Into</a> :A <a href="#string-type">String</a>) (<a href="#monadioterm-class">MonadIoTerm</a> :B) &rArr; (:A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Perform a synchrozied write-line to the terminal. Not performant - mainly useful
for debugging.</p><h4 id=unmask-thread-finally_-value><a href="#unmask-thread-finally_-value"><code>(UNMASK-THREAD-FINALLY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L39-L39">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) &rArr; (<a href="#iothread-type">IoThread</a> &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (:B <a href="#unit-type">Unit</a>))</code><h4 id=fork-thread-throw_-value><a href="#fork-thread-throw_-value"><code>(FORK-THREAD-THROW_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L34-L34">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#iothread-type">IoThread</a>))</code><h4 id=unmask-finally_-value><a href="#unmask-finally_-value"><code>(UNMASK-FINALLY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L44-L44">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :D) (<a href="#monadexception-class">MonadException</a> :D) (<a href="#concurrent-class">Concurrent</a> :B :A) (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :D) &rArr; (:B &rarr; (<a href="#unmaskfinallymode-type">UnmaskFinallyMode</a> &rarr; (<a href="#io-type">IO</a> :C)) &rarr; (:D <a href="#unit-type">Unit</a>))</code><h4 id=fork-thread_-value><a href="#fork-thread_-value"><code>(FORK-THREAD_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-thread.lisp#L30-L30">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B <a href="#iothread-type">IoThread</a>))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-classes-monad-io-thread-derive-monad-io-thread-macro><a href="#io-classes-monad-io-thread-derive-monad-io-thread-macro"><code>DERIVE-MONAD-IO-THREAD (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoThread for a monad transformer.

Example:
  (derive-monad-io-thread :m (st:StateT :s :m))</p><h4
    id=io-io-impl-thread-do-fork-thread-throw_-macro><a href="#io-io-impl-thread-do-fork-thread-throw_-macro"><code>DO-FORK-THREAD-THROW_ (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-thread-do-fork-thread-macro><a href="#io-classes-monad-io-thread-do-fork-thread-macro"><code>DO-FORK-THREAD (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-gen-impl-thread-implement-monad-io-thread-macro><a href="#io-gen-impl-thread-implement-monad-io-thread-macro"><code>IMPLEMENT-MONAD-IO-THREAD (MONAD RUNTIME THREAD)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-thread-do-fork-thread-throw-macro><a href="#io-classes-monad-io-thread-do-fork-thread-throw-macro"><code>DO-FORK-THREAD-THROW (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-thread-do-fork-thread_-macro><a href="#io-io-impl-thread-do-fork-thread_-macro"><code>DO-FORK-THREAD_ (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/file-package">Package <code>IO/FILE</code></h1><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiofile-class><a href="#monadiofile-class"><code>MonadIoFile</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-file.lisp#L57-L137">src</a></sub></sup></sub></sup></h4><code><a href="#monadio-class">MonadIo</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns whether a file or directory exists.</span>
        <li class=methods-item><code>FILE-EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns True if a pathname names a file that exists.</span>
        <li class=methods-item><code>DIRECTORY-EXISTS? :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>)))</code><span><br>Returns True if a pathname names a directory that exists.</span>
        <li class=methods-item><code>OPEN :: <a href="#file-class">File</a> :A &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#filestream-type">FileStream</a> :A))))</code>
        <li class=methods-item><code>CLOSE :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :C)))</code><span><br>Closes a FileStream.</span>
        <li class=methods-item><code>ABORT :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :C)))</code><span><br>Closes a FileStream and aborts all operations..</span>
        <li class=methods-item><code>CREATE-TEMP-DIRECTORY :: (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>))</code>
        <li class=methods-item><code>CREATE-TEMP-FILE :: (<a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code>
        <li class=methods-item><code>COPY :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#into-class">Into</a> :B <a href="#pathname-type">Pathname</a>) &rArr; (:A &rarr; :B &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Copies a file to a new location.</span>
        <li class=methods-item><code>CREATE-DIRECTORY :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code><span><br>This is equivalent to `mkdir -p`. Creates a directory and its parents. The pathname must be a valid directory pathname.</span>
        <li class=methods-item><code>DELETE-FILE :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Deletes a given file if the file exists.</span>
        <li class=methods-item><code>REMOVE-DIRECTORY :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :A)))</code><span><br>Deletes an empty directory.</span>
        <li class=methods-item><code>REMOVE-DIRECTORY-RECURSIVE :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Deletes a target directory recursively. Equivalent to `rm -r`. Errors if the path is not a directory.</span>
        <li class=methods-item><code>SYSTEM-RELATIVE-PATHNAME :: <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; <a href="#string-type">String</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>)))</code><span><br>Generates a system-relative-pathname for a given filename or path. This is a wrapper for `asdf:system-relative-pathname`. `Name` will likely be an empty string unless a subdirectory or filename is specified.</span>
        <li class=methods-item><code>READ-FILE-TO-STRING :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>)))</code><span><br>Reads a file into a string, given a pathname string.</span>
        <li class=methods-item><code>READ-FILE-LINES :: <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>))))</code><span><br>Reads a file into lines, given a pathname or string.</span>
        <li class=methods-item><code>READ-CHAR :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#char-type">Char</a>)))</code><span><br>Reads a character from an FileStream.</span>
        <li class=methods-item><code>READ-LINE :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>)))</code>
        <li class=methods-item><code>WRITE-CHAR :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#char-type">Char</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a `Char` to the stream.</span>
        <li class=methods-item><code>WRITE-LINE :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a string with an appended newline to a filestream of type Char.</span>
        <li class=methods-item><code>WRITE-STRING :: ((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (:A (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes a `string` to a FileStream of type Char.</span>
        <li class=methods-item><code>READ-FILE-TO-VECTOR :: <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A))))</code><span><br>Reads a file into a vector of type `:a`.</span>
        <li class=methods-item><code>READ-VECTOR :: <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A))))</code><span><br>Reads a chunk of a file into a vector of type `:a`.</span>
        <li class=methods-item><code>WRITE-VECTOR :: (<a href="#file-class">File</a> :A) (<a href="#runtimerepr-class">RuntimeRepr</a> :A) &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#vector-type">Vector</a> :A) &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Writes elements of an vector of type `:a` to a stream of type `:a`.</span>
        <li class=methods-item><code>WRITE-TO-FILE :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#file-class">File</a> :B) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) &rArr; (:A &rarr; (<a href="#vector-type">Vector</a> :B) &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Opens and writes to a file with data of type :a. Supersedes existing data on the file.</span>
        <li class=methods-item><code>APPEND-TO-FILE :: (<a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a>) (<a href="#file-class">File</a> :B) (<a href="#runtimerepr-class">RuntimeRepr</a> :B) &rArr; (:A &rarr; (<a href="#vector-type">Vector</a> :B) &rarr; (:C (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Opens and appends a file with data of type :a.</span>
        <li class=methods-item><code>SET-FILE-POSITION :: ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (:B (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>)))</code><span><br>Sets the file position of a file stream.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> <a href="#io-type">IO</a></code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiofile-class">MonadIoFile</a> :A &rArr; <a href="#monadiofile-class">MonadIoFile</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=copy-value><a href="#copy-value"><code>(COPY V)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/lisparray.lisp#L93-L96">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#lisparray-type">LispArray</a> :A) &rarr; (<a href="#lisparray-type">LispArray</a> :A))</code><p class=docstring>Make a deep copy of the `LispArray` `v`.</p><h4 id=copy-value><a href="#copy-value"><code>(COPY V)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/vector.lisp#L132-L137">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#vector-type">Vector</a> :A) &rarr; (<a href="#vector-type">Vector</a> :A))</code><p class=docstring>Return a new vector containing the same elements as `v`.</p><h4 id=copy-value><a href="#copy-value"><code>(COPY Q)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/queue.lisp#L76-L92">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#queue-type">Queue</a> :A) &rarr; (<a href="#queue-type">Queue</a> :A))</code><p class=docstring>Return a new queue containing the same elements as `q`.</p><h4 id=system-relative-pathname-value><a href="#system-relative-pathname-value"><code>(SYSTEM-RELATIVE-PATHNAME SYSTEM-NAME NAME)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L320-L324">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#string-type">String</a> &rArr; (:A &rarr; <a href="#string-type">String</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#pathname-type">Pathname</a>))</code><p class=docstring>Generates a system-relative-pathname for a given filename or path. This is a wrapper for `asdf:system-relative-pathname`. `Name` will likely be an empty string unless a subdirectory or filename is specified.</p><h4 id=with-temp-directory-value><a href="#with-temp-directory-value"><code>(WITH-TEMP-DIRECTORY THUNK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L696-L701">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#pathname-type">Pathname</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :A)) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :A))</code><p class=docstring>Performs an operation `thunk` inside a temporary directory.</p><h4 id=read-file-to-vector-value><a href="#read-file-to-vector-value"><code>(READ-FILE-TO-VECTOR STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L595-L604">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A)))</code><p class=docstring>Reads a file into a vector of type `:a`.</p><h4 id=read-file-to-string-value><a href="#read-file-to-string-value"><code>(READ-FILE-TO-STRING PATH)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L734-L738">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>))</code><p class=docstring>Reads a file into a string, given a pathname string.</p><h4 id=set-file-position-value><a href="#set-file-position-value"><code>(SET-FILE-POSITION STREAM I)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L497-L500">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Sets the file position of a file stream.</p><h4 id=directory-exists?-value><a href="#directory-exists?-value"><code>(DIRECTORY-EXISTS? PATH)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L220-L226">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Returns True if a pathname names a directory that exists.</p><h4 id=read-file-lines-value><a href="#read-file-lines-value"><code>(READ-FILE-LINES PATH)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L741-L745">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>)))</code><p class=docstring>Reads a file into lines, given a pathname or string.</p><h4 id=with-temp-file-value><a href="#with-temp-file-value"><code>(WITH-TEMP-FILE FILE-TYPE THUNK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L686-L693">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#file-class">File</a> :A &rArr; (<a href="#string-type">String</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B)) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B))</code><p class=docstring>Performs an operation `thunk` on a temporary file. File type extensions need to include `.`, like &quot;.txt&quot;.</p><h4 id=with-open-file-value><a href="#with-open-file-value"><code>(WITH-OPEN-FILE STREAM-OPTIONS THUNK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L570-L574">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#file-class">File</a> :A &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B)) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B))</code><p class=docstring>Opens a file stream, performs `thunk` on it, then closes the stream.</p><h4 id=write-vector-value><a href="#write-vector-value"><code>(WRITE-VECTOR STREAM V)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L610-L614">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#runtimerepr-class">RuntimeRepr</a> :A) (<a href="#file-class">File</a> :A) &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#vector-type">Vector</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Writes elements of an vector of type `:a` to a stream of type `:a`.</p><h4 id=write-string-value><a href="#write-string-value"><code>(WRITE-STRING FS S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L617-L619">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Writes a `string` to a FileStream of type Char.</p><h4 id=file-exists?-value><a href="#file-exists?-value"><code>(FILE-EXISTS? PATH)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L229-L237">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Returns True if a pathname names a file that exists.</p><h4 id=read-vector-value><a href="#read-vector-value"><code>(READ-VECTOR STREAM CHUNK-SIZE)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L581-L589">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#file-class">File</a> :A &rArr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; <a href="#ufix-type">UFix</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> (<a href="#vector-type">Vector</a> :A)))</code><p class=docstring>Reads a chunk of a file into a vector of type `:a`.</p><h4 id=write-line-value><a href="#write-line-value"><code>(WRITE-LINE STREAM S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L622-L625">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#string-type">String</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Writes a string with an appended newline to a filestream of type Char.</p><h4 id=write-char-value><a href="#write-char-value"><code>(WRITE-CHAR STREAM DATA)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L462-L465">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; <a href="#char-type">Char</a> &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#unit-type">Unit</a>))</code><p class=docstring>Writes a `Char` to the stream.</p><h4 id=read-line-value><a href="#read-line-value"><code>(READ-LINE STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L454-L459">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#string-type">String</a>))</code><p class=docstring>Reads a line of characters from a FileStream.</p><h4 id=read-char-value><a href="#read-char-value"><code>(READ-CHAR STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L446-L451">src</a></sub></sup></sub></sup></h4><code>((<a href="#filestream-type">FileStream</a> <a href="#char-type">Char</a>) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#char-type">Char</a>))</code><p class=docstring>Reads a character from an FileStream.</p><h4 id=exists?-value><a href="#exists?-value"><code>(EXISTS? PATH)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L201-L205">src</a></sub></sup></sub></sup></h4><code>&forall; :A. <a href="#into-class">Into</a> :A <a href="#pathname-type">Pathname</a> &rArr; (:A &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Returns whether a file or directory exists.</p><h4 id=close-value><a href="#close-value"><code>(CLOSE STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L434-L437">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B))</code><p class=docstring>Closes a FileStream.</p><h4 id=abort-value><a href="#abort-value"><code>(ABORT STREAM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/file.lisp#L440-L443">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#result-type">Result</a> <a href="#fileerror-type">FileError</a> :B))</code><p class=docstring>Closes a FileStream and aborts all operations..</p><h4 id=copy-value><a href="#copy-value"><code>(COPY SEQ)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/seq.lisp#L459-L465">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#seq-type">Seq</a> :A) &rarr; (<a href="#seq-type">Seq</a> :A))</code><p class=docstring>A shallow copy of `seq`</p><h4 id=with-temp-directory-value><a href="#with-temp-directory-value"><code>(WITH-TEMP-DIRECTORY K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L249-L260">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; ((<a href="#pathname-type">Pathname</a> &rarr; (:D :E)) &rarr; (:F :E))</code><p class=docstring>Performs an operation `thunk` inside a temporary directory.
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-TEMP-DIRECTORY_ if you have issues.</p><h4 id=with-temp-file-value><a href="#with-temp-file-value"><code>(WITH-TEMP-FILE FILE-TYPE K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L230-L243">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#file-class">File</a> :D) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadexception-class">MonadException</a> :A) &rArr; (<a href="#string-type">String</a> &rarr; ((<a href="#filestream-type">FileStream</a> :D) &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Performs an operation `thunk` on a temporary file. File type extensions need to include `.`
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-TEMP-FILE_ if you have issues.</p><h4 id=with-open-file-value><a href="#with-open-file-value"><code>(WITH-OPEN-FILE OPTS K)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/io-file.lisp#L211-L223">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#file-class">File</a> :D) (<a href="#monadiofile-class">MonadIoFile</a> :A) (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; ((<a href="#filestream-type">FileStream</a> :D) &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Opens a file stream, performs K on it, then closes the stream.
Can run any underlying BaseIo, which can be useful but can also cause inference issues
in some cases. Try WITH-OPEN-FILE_ if you have issues.</p><h4 id=with-temp-directory_-value><a href="#with-temp-directory_-value"><code>(WITH-TEMP-DIRECTORY_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L43-L43">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#unliftio-class">UnliftIo</a> :B <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#pathname-type">Pathname</a> &rarr; (<a href="#io-type">IO</a> :A)) &rarr; (:B :A))</code><h4 id=with-temp-file_-value><a href="#with-temp-file_-value"><code>(WITH-TEMP-FILE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L38-L38">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#file-class">File</a> :A) (<a href="#unliftio-class">UnliftIo</a> :C <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; (<a href="#string-type">String</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code><h4 id=with-open-file_-value><a href="#with-open-file_-value"><code>(WITH-OPEN-FILE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-file.lisp#L32-L32">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#file-class">File</a> :A) (<a href="#unliftio-class">UnliftIo</a> :C <a href="#io-type">IO</a>) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; (<a href="#streamoptions-type">StreamOptions</a> &rarr; ((<a href="#filestream-type">FileStream</a> :A) &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-file-do-with-temp-directory-macro><a href="#io-gen-impl-file-do-with-temp-directory-macro"><code>DO-WITH-TEMP-DIRECTORY ((DIR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-directory`.</p><h4
    id=io-io-impl-file-do-with-temp-directory_-macro><a href="#io-io-impl-file-do-with-temp-directory_-macro"><code>DO-WITH-TEMP-DIRECTORY_ ((DIR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-directory_`.</p><h4
    id=io-io-impl-file-do-with-open-file_-macro><a href="#io-io-impl-file-do-with-open-file_-macro"><code>DO-WITH-OPEN-FILE_ (OPTS (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-open-file_`. Expands to a continuation where BODY runs in `do`.

Usage:
  (do-with-open-file_ opts (fs)
    (line &lt;- (read-char fs))
    ...)
</p><h4
    id=io-classes-monad-io-file-derive-monad-io-file-macro><a href="#io-classes-monad-io-file-derive-monad-io-file-macro"><code>DERIVE-MONAD-IO-FILE (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Derive a `MonadIoFile` instance for MONADT-FORM by lifting into the base instance.

Example:
  (derive-monad-io-file :m (st:StateT :s :m))</p><h4
    id=io-gen-impl-file-implement-monad-io-file-macro><a href="#io-gen-impl-file-implement-monad-io-file-macro"><code>IMPLEMENT-MONAD-IO-FILE (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-io-impl-file-do-with-temp-file_-macro><a href="#io-io-impl-file-do-with-temp-file_-macro"><code>DO-WITH-TEMP-FILE_ (TYPE (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-file_` (TYPE is a string like &quot;txt&quot;).</p><h4
    id=io-gen-impl-file-do-with-temp-file-macro><a href="#io-gen-impl-file-do-with-temp-file-macro"><code>DO-WITH-TEMP-FILE (TYPE (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-temp-file` (TYPE is a string like &quot;txt&quot;).</p><h4
    id=io-gen-impl-file-do-with-open-file-macro><a href="#io-gen-impl-file-do-with-open-file-macro"><code>DO-WITH-OPEN-FILE (OPTS (FS) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>`do` sugar for `with-open-file`. Expands to a continuation where BODY runs in `do`.

Usage:
  (do-with-open-file opts (fs)
    (line &lt;- (read-char fs))
    ...)
</p></div>
      <hr><h1 id="io/unique-package">Package <code>IO/UNIQUE</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=unique-type><a href="#unique-type"><code>Unique</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L31-L32">src</a></sub></sup></sub></sup></h4><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> <a href="#integer-type">Integer</a> &rArr; <a href="#eq-class">Eq</a> <a href="#unique-type">Unique</a></code>
         <li class=instances-item><code><a href="#ord-class">Ord</a> <a href="#unique-type">Unique</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> <a href="#unique-type">Unique</a></code></ul></details></div>
      <hr><div class=classes-content>
       <h3 class=classes-header>Classes</h3><h4 id=monadiounique-class><a href="#monadiounique-class"><code>MonadIoUnique</code></a> <sup><sub>CLASS · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L47-L52">src</a></sub></sup></sub></sup></h4><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> :A</code><span>Methods:</span>
       <ul class=methods-list>
        <li class=methods-item><code>NEW-UNIQUE :: (:A <a href="#unique-type">Unique</a>)</code><span><br>Generate a value that will be unique within this run of the program.&#xA;Threadsafe - calling from different threads will still result in unique&#xA;values across all threads.</span></ul><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> (<a href="#loopt-type">LoopT</a> :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#envt-type">EnvT</a> :B) :A)</code>
         <li class=instances-item><code><a href="#monadiounique-class">MonadIoUnique</a> :A &rArr; <a href="#monadiounique-class">MonadIoUnique</a> ((<a href="#statet-type">StateT</a> :B) :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=to-int-value><a href="#to-int-value"><code>(TO-INT (UNIQUE% I))</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/classes/monad-io-unique.lisp#L40-L45">src</a></sub></sup></sub></sup></h4><code>(<a href="#unique-type">Unique</a> &rarr; <a href="#integer-type">Integer</a>)</code><p class=docstring>Convert a unique value to an integer.

It is guaranteed that: (/= (to-int a) (to-int b))
for any two different Unique instances.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-unique-implement-monad-io-unique-macro><a href="#io-gen-impl-unique-implement-monad-io-unique-macro"><code>IMPLEMENT-MONAD-IO-UNIQUE (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-classes-monad-io-unique-derive-monad-io-unique-macro><a href="#io-classes-monad-io-unique-derive-monad-io-unique-macro"><code>DERIVE-MONAD-IO-UNIQUE (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Automatically derive an instance of MonadIoUnique for a monad transformer.

Example:
  (derive-monad-io-unique :m (st:StateT :s :m))</p></div>
      <hr><h1 id="io/conc/future-package">Package <code>IO/CONC/FUTURE</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=future-type><a href="#future-type"><code>Future :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L32-L42">src</a></sub></sup></sub></sup></h4><p class=docstring>Container for an value that will eventually be returned by a concurrent operation.

Concurrent:
  - Future&#39;s `(Concurrent Future :a)` instance defers to the underlying thread, so it takes
    on masking semantics of the underyling thread&#39;s `Concurrent` instance.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#future-type">Future</a> :A) :A</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#future-type">Future</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=try-read-future-value><a href="#try-read-future-value"><code>(TRY-READ-FUTURE FUTURE)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L88-L100">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :D) (<a href="#monadexception-class">MonadException</a> :D) &rArr; ((<a href="#future-type">Future</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Try to read the current value from FUTURE, returning NONE
if it is not available. Raises any exceptions in the awaiting thread
that were raised in the future thread.</p><h4 id=fork-future-value><a href="#fork-future-value"><code>(FORK-FUTURE TASK)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-future.lisp#L48-L74">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F. (<a href="#monadexception-class">MonadException</a> :D) (<a href="#liftto-class">LiftTo</a> :D :F) (<a href="#unliftio-class">UnliftIo</a> :D :A) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :D) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :F) &rArr; ((:D :E) &rarr; (:F (<a href="#future-type">Future</a> :E)))</code><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p><h4 id=fork-future_-value><a href="#fork-future_-value"><code>(FORK-FUTURE_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-future.lisp#L25-L29">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :B) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :B) &rArr; ((<a href="#io-type">IO</a> :A) &rarr; (:B (<a href="#future-type">Future</a> :A)))</code><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-gen-impl-conc-future-do-fork-future-macro><a href="#io-gen-impl-conc-future-do-fork-future-macro"><code>DO-FORK-FUTURE (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Spawn a new future, which will run and eventually return the result
from TASK. The future is guaranteed to only ever run at most once, when
the produced :m is run.</p><h4
    id=io-io-impl-future-do-fork-future_-macro><a href="#io-io-impl-future-do-fork-future_-macro"><code>DO-FORK-FUTURE_ (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/conc/atomic-package">Package <code>IO/CONC/ATOMIC</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=atvar-type><a href="#atvar-type"><code>AtVar</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L34-L38">src</a></sub></sup></sub></sup></h4><p class=docstring>A container that can be read and modified atomically.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#atvar-type">AtVar</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=modify-swap-value><a href="#modify-swap-value"><code>(MODIFY-SWAP FS-&gt;S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/monad/state.lisp#L77-L80">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((:A &rarr; :A) &rarr; (<a href="#st-type">ST</a> :A :A))</code><p class=docstring>Modify the state in a StatefulComputation, returning the old state.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY FS-&gt;S)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/monad/state.lisp#L56-L59">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((:A &rarr; :A) &rarr; (<a href="#st-type">ST</a> :A <a href="#unit-type">Unit</a>))</code><p class=docstring>Modify the state in a StatefulComputation, discarding the old state.</p><h4 id=modify-swap-value><a href="#modify-swap-value"><code>(MODIFY-SWAP ATM F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L77-L85">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Atomically modify `atm` by applying `f` and return the old value. `f` must be a pure
function. If `f` throws an error, `atm` will be unchanged and the error will be handleable
via `MonadException`.

Concurrent:
  - WARNING: `f` will be retried each time the calling thread loses the race to update
    `atm`, so `f` must be pure.</p><h4 id=new-at-var-value><a href="#new-at-var-value"><code>(NEW-AT-VAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L47-L49">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; (:A &rarr; (:B (<a href="#atvar-type">AtVar</a> :A)))</code><p class=docstring>Create a new AtVar containing `val`.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY ATM F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L65-L73">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. (<a href="#monadio-class">MonadIo</a> :B) (<a href="#monadexception-class">MonadException</a> :B) &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:A &rarr; :A) &rarr; (:B :A))</code><p class=docstring>Atomically modify `atm` by applying `f` and return the new value. `f` must be a pure
function. If `f` throws an error, `atm` will be unchanged and the error will be handleable
via `MonadException`.

Concurrent:
  - WARNING: `f` will be retried each time the calling thread loses the race to update
    `atm`, so `f` must be pure.</p><h4 id=write-value><a href="#write-value"><code>(WRITE ATM VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L59-L61">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; :A &rarr; (:B <a href="#unit-type">Unit</a>))</code><p class=docstring>Atomically write a new value to `atm`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L53-L55">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> :A) &rarr; (:B :A))</code><p class=docstring>Atomically read the value from `atm`.</p><h4 id=push-value><a href="#push-value"><code>(PUSH ATM ELT)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L89-L91">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> (<a href="#list-type">List</a> :A)) &rarr; :A &rarr; (:B (<a href="#list-type">List</a> :A)))</code><p class=docstring>Atomically push a value onto an atomic list. Returns the new list.</p><h4 id=pop-value><a href="#pop-value"><code>(POP ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-atomic.lisp#L95-L97">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#atvar-type">AtVar</a> (<a href="#list-type">List</a> :A)) &rarr; (:B (<a href="#optional-type">Optional</a> :A)))</code><p class=docstring>Atomically pop and retrieve the head of an atomic list.</p><h4 id=modify-value><a href="#modify-value"><code>(MODIFY HM KEY F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/hashmap.lisp#L626-L628">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#hash-class">Hash</a> :A &rArr; ((<a href="#hashmap-type">HashMap</a> :A :B) &rarr; :A &rarr; (:B &rarr; :B) &rarr; (<a href="#hashmap-type">HashMap</a> :A :B))</code><p class=docstring>Modify the value at KEY with F. Returns the modified `HashMap`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATM)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/thread-impl/atomics.lisp#L84-L87">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#atomic-type">Atomic</a> :A) &rarr; :A)</code><p class=docstring>Read the value of an atomic cell `atm`.</p><h4 id=read-value><a href="#read-value"><code>(READ ATOMIC)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/atomic.lisp#L47-L50">src</a></sub></sup></sub></sup></h4><code>(<a href="#atomicinteger-type">AtomicInteger</a> &rarr; <a href="#u64-type">U64</a>)</code><p class=docstring>Returns the current value of `atomic&#39;.</p><h4 id=read-value><a href="#read-value"><code>(READ MUTEX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton-threads/src/mutex.lisp#L27-L31">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#mutex-type">Mutex</a> :A) &rarr; :A)</code><p class=docstring>Access the value held in a Mutex.</p><h4 id=read-value><a href="#read-value"><code>(READ CEL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/cell.lisp#L53-L56">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#cell-type">Cell</a> :A) &rarr; :A)</code><p class=docstring>Read the value of a mutable cell `cel`.</p><h4 id=push-value><a href="#push-value"><code>(PUSH SEQ A)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/seq.lisp#L118-L126">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#seq-type">Seq</a> :A) &rarr; :A &rarr; (<a href="#seq-type">Seq</a> :A))</code><p class=docstring>Push `a` onto the end of `seq`, returning a new `Seq` instance.</p><h4 id=pop-value><a href="#pop-value"><code>(POP SEQ)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master//home/jasonw/.roswell/local-projects/coalton/library/seq.lisp#L128-L165">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((<a href="#seq-type">Seq</a> :A) &rarr; (<a href="#optional-type">Optional</a> (<a href="#tuple-type">Tuple</a> :A (<a href="#seq-type">Seq</a> :A))))</code><p class=docstring>If `seq` is empty, return `None`. Otherwise, the last member of `seq` and
a new `Seq` instance.</p></div>
      <hr><h1 id="io/conc/mvar-package">Package <code>IO/CONC/MVAR</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=mchan-type><a href="#mchan-type"><code>MChan :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L404-L407">src</a></sub></sup></sub></sup></h4><p class=docstring>A synchronized FIFO queue to pass data directionally between threads.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#mchan-type">MChan</a> :A)</code></ul></details><h4 id=mvar-type><a href="#mvar-type"><code>MVar :A</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L51-L60">src</a></sub></sup></sub></sup></h4><p class=docstring>A synchronized container that can be empty or hold an :a.

All critical MVar operations are masked. However, irresponsible stopping could still cause
deadlocks and other race conditions.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#mvar-type">MVar</a> :A)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=take-mvar-masked-value><a href="#take-mvar-masked-value"><code>(TAKE-MVAR-MASKED MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L121-L133">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - WARNING: Leaves the thread masked when returns to protect caller&#39;s critical regions
    based on consuming and restoring MVar to a valid state. See MChan for an example.
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar-masked`) are woken individual on succesfull puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=new-empty-mvar-value><a href="#new-empty-mvar-value"><code>NEW-EMPTY-MVAR</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L75-L82">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C (<a href="#mvar-type">MVar</a> :D))</code><p class=docstring>Create a new empty MVar.</p><h4 id=new-empty-chan-value><a href="#new-empty-chan-value"><code>NEW-EMPTY-CHAN</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L410-L416">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :C &rArr; (:C (<a href="#mchan-type">MChan</a> :D))</code><p class=docstring>Create a new empty channel.</p><h4 id=try-take-mvar-value><a href="#try-take-mvar-value"><code>(TRY-TAKE-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L201-L233">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to immediately take a value from an MVar. Returns None if empty.

Concurrent:
  - Can briefly block while waiting to empty the MVar, if contended
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=try-read-mvar-value><a href="#try-read-mvar-value"><code>(TRY-READ-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L292-L295">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D (<a href="#optional-type">Optional</a> :C)))</code><p class=docstring>Attempt to immediately read a value from an MVar. Returns None if empty.</p><h4 id=is-empty-mvar-value><a href="#is-empty-mvar-value"><code>(IS-EMPTY-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L336-L339">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Return True if the MVar is currently empty.</p><h4 id=try-put-mvar-value><a href="#try-put-mvar-value"><code>(TRY-PUT-MVAR MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L236-L271">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D <a href="#boolean-type">Boolean</a>))</code><p class=docstring>Attempt to immediately put a value into an MVar. Returns True if succeeded.

Concurrent:
  - Can briefly block while waiting to fill the MVar, if contended
  - On succesful put, blocking read-consumers are woken individually in order of acquisition
  - On succesful put, all blocking read-non-consumers are woken simultaneously. New data
    is handed directly to woken read-non-consumers so they don&#39;t contend on the MVar.</p><h4 id=with-mvar-value><a href="#with-mvar-value"><code>(WITH-MVAR MVAR OP)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L351-L374">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E :F :G. (<a href="#unliftio-class">UnliftIo</a> :E :A) (<a href="#liftto-class">LiftTo</a> :E :G) (<a href="#monadiothread-class">MonadIoThread</a> :B :C :A) &rArr; ((<a href="#mvar-type">MVar</a> :D) &rarr; (:D &rarr; (:E :F)) &rarr; (:G :F))</code><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Restore the MVar value and return the result of the operation.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p><h4 id=take-mvar-value><a href="#take-mvar-value"><code>(TAKE-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L137-L151">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Take a value from an MVar, blocking until one is available.

Concurrent:
  - Blocks while the MVar is empty
  - Read-consumers (including `take-mvar`) are woken individual on succesful puts,
    in order of acquisition
  - On succesful take, one blocking writer is woken in order of acquisition</p><h4 id=swap-mvar-value><a href="#swap-mvar-value"><code>(SWAP-MVAR MVAR NEW-VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L298-L333">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D :C))</code><p class=docstring>Atomically replace the value in an MVar and return the old value.

Concurrent:
  - Blocks while the MVar is empty
  - Wakes the next blocking read-consumer when `swap-mvar` completes</p><h4 id=read-mvar-value><a href="#read-mvar-value"><code>(READ-MVAR MVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L274-L289">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; (:D :C))</code><p class=docstring>Read a value from an MVar, blocking until one is available. Does not consume value.

Concurrent:
  - Blocks while the MVar is empty
  - Blocking read-non-consumers (including `read-mvar`) are woken simultaneously on 
    succesful put. Data is handed directly to woken readers, which don&#39;t contend on mvar.</p><h4 id=push-chan-value><a href="#push-chan-value"><code>(PUSH-CHAN CHAN VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L419-L426">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mchan-type">MChan</a> :C) &rarr; :C &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Push VAL onto CHAN.</p><h4 id=put-mvar-value><a href="#put-mvar-value"><code>(PUT-MVAR MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L154-L198">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mvar-type">MVar</a> :C) &rarr; :C &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Fill an empty MVar, blocking until it becomes empty.

Concurrent:
  - Blocks while the MVar is full
  - Writers (including `put-mvar`) are woken individual on succesful takes in order
    of acquisition
  - On succesful put, blocking read-consumers are woken individually in order of acquisition
  - On succesful put, all blocking read-non-consumers are woken simultaneously. New data
    is handed directly to woken read-non-consumers so they don&#39;t contend on the MVar.</p><h4 id=pop-chan-value><a href="#pop-chan-value"><code>(POP-CHAN CHAN)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L429-L436">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; ((<a href="#mchan-type">MChan</a> :C) &rarr; (:D :C))</code><p class=docstring>Pop the front value in CHAN. Blocks while CHAN is empty.</p><h4 id=new-mvar-value><a href="#new-mvar-value"><code>(NEW-MVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/io-mvar.lisp#L64-L71">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. <a href="#monadiothread-class">MonadIoThread</a> :A :B :D &rArr; (:C &rarr; (:D (<a href="#mvar-type">MVar</a> :C)))</code><p class=docstring>Create a new MVar containing VAL.</p><h4 id=with-mvar_-value><a href="#with-mvar_-value"><code>(WITH-MVAR_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/io-mvar.lisp#L25-L38">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :C) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :C) &rArr; ((<a href="#mvar-type">MVar</a> :A) &rarr; (:A &rarr; (<a href="#io-type">IO</a> :B)) &rarr; (:C :B))</code><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Restore the MVar value and return the result of the operation.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-io-impl-mvar-do-with-mvar_-macro><a href="#io-io-impl-mvar-do-with-mvar_-macro"><code>DO-WITH-MVAR_ ((SYM MVAR) &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run an operation with the value from an MVar, blocking until one is available.
Stores the result of the operation in the MVar and returns.

WARNING: If the computation raises an unhandled exception or is stopped, leaves the MVar
empty!

Concurrent:
  - WARNING: Does not mask during the computation. To ensure completion, caller must mask
  - Blocks while the MVar is empty
  - Inherits notify semantics from `put-mvar`
  - Does not leave the MVar locked during the computation. Thus, other threads can
    put the MVar during the computation and force `with-mvar` to block until empty.</p></div>
      <hr><h1 id="io/conc/group-package">Package <code>IO/CONC/GROUP</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=concurrentgroup-type><a href="#concurrentgroup-type"><code>ConcurrentGroup :A :B</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L32-L56">src</a></sub></sup></sub></sup></h4><p class=docstring>Handles masking, stopping, and awaiting a group of Concurrents as a unit. ConcurrentGroup
does not pass messages/data. For more structured uses, see WorkerPool.

ConcurrentGroup provides the following guarantees:
* Masking/unmasking the group is atomic. If another thread attempts to stop the group, it will
  either stop all of the Concurrents or none of them.
* Stopping the group sends the stop signal to all of the enclosed Concurrents.
* Awaiting the group blocks until all of the enclosed Concurrents have completed.
* Awaiting the group will error if any one of the enclosed Concurrents errored.
* Calling unmask-finally on the group runs the callback on each Concurrent separately, not
  once on the thread calling (unmask-finally).

ConcurrentGroup&#39;s guarantees are only valid if management of the enclosed Concurrents is
done through the group. For example, if one thread tries to mask the group while another
thread tries to stop one of the individual Concurrents in the group, then the second
thread might stop the individual Concurrent before the first thread has a chance to mask
it.

Concurrent:
  - The `(Concurrent ConcurrentGroup :a)&#39; instance masks `stop`, `mask`, `unmask`,
    and `unmask-finally` to guarantee atomicity of the enclosed Concurrents
  - `await` is not masked</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> :A :B &rArr; <a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B) (<a href="#list-type">List</a> :B)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A :B)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=enclose-group-value><a href="#enclose-group-value"><code>(ENCLOSE-GROUP CONCURRENTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L83-L87">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :D) (<a href="#concurrent-class">Concurrent</a> :C :E) &rArr; ((<a href="#list-type">List</a> :C) &rarr; (:D (<a href="#concurrentgroup-type">ConcurrentGroup</a> :C :E)))</code><p class=docstring>Enclose already forked Concurrents in a ConcurrentGroup.

Warning: After calling, the enclosed Concurrents should only be managed through the group.</p><h4 id=fork-group-value><a href="#fork-group-value"><code>(FORK-GROUP FORK-CONCURRENTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/concurrent-group.lisp#L70-L79">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#concurrent-class">Concurrent</a> :D :E) &rArr; ((<a href="#list-type">List</a> (:C :D)) &rarr; (:C (<a href="#concurrentgroup-type">ConcurrentGroup</a> :D :E)))</code><p class=docstring>Run a list of IO operations that each forks a Concurrent. Enclose the forked Concurrents in a
ConcurrentGroup.

Concurrent:
  - Does not mask the forking operation, so it is possible to partially fork if stopped.
    To guarantee forking completion, caller should mask the call to `fork-group`.</p></div>
      <hr><h1 id="io/conc/stm-package">Package <code>IO/CONC/STM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=tvar-type><a href="#tvar-type"><code>TVar</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L61-L63">src</a></sub></sup></sub></sup></h4><p class=docstring>A Transaction Variable that can be read and modified inside an STM transaction.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#eq-class">Eq</a> (<a href="#cell-type">Cell</a> :A) &rArr; <a href="#eq-class">Eq</a> (<a href="#tvar-type">TVar</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> (<a href="#tvar-type">TVar</a> :A)</code></ul></details><h4 id=stm-type><a href="#stm-type"><code>STM</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L110-L112">src</a></sub></sup></sub></sup></h4><p class=docstring>A transaction that can be run using `run-tx`.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code>(<a href="#monadexception-class">MonadException</a> :A) (<a href="#monadio-class">MonadIo</a> :A) &rArr; <a href="#monadexception-class">MonadException</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#functor-class">Functor</a> :A &rArr; <a href="#functor-class">Functor</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#applicative-class">Applicative</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#monad-class">Monad</a> :A &rArr; <a href="#monad-class">Monad</a> (<a href="#stm-type">STM</a> :A)</code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> ((<a href="#stm-type">STM</a> :A) :B)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=modify-swap-tvar-value><a href="#modify-swap-tvar-value"><code>(MODIFY-SWAP-TVAR TVAR F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L590-L605">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; (:A &rarr; :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Modify a mutable variable inside an atomic transaction. Returns the old value.</p><h4 id=modify-tvar-value><a href="#modify-tvar-value"><code>(MODIFY-TVAR TVAR F)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L573-L588">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; (:A &rarr; :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Modify a mutable variable inside an atomic transaction. Returns the new value.</p><h4 id=write-tvar-value><a href="#write-tvar-value"><code>(WRITE-TVAR TVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L547-L553">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; :A &rarr; ((<a href="#stm-type">STM</a> :B) <a href="#unit-type">Unit</a>))</code><p class=docstring>Write to a mutable variable inside an atomic transaction.</p><h4 id=swap-tvar-value><a href="#swap-tvar-value"><code>(SWAP-TVAR TVAR NEW-VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L555-L571">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; :A &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Swap the value of a mutable variable inside an atomic transaction. Returns the old
value.</p><h4 id=read-tvar-value><a href="#read-tvar-value"><code>(READ-TVAR TVAR)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L538-L544">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; ((<a href="#tvar-type">TVar</a> :A) &rarr; ((<a href="#stm-type">STM</a> :B) :A))</code><p class=docstring>Read a mutable variable inside an atomic transaction.</p><h4 id=new-tvar-value><a href="#new-tvar-value"><code>(NEW-TVAR VAL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L403-L408">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :B &rArr; (:A &rarr; (:B (<a href="#tvar-type">TVar</a> :A)))</code><p class=docstring>Create a mutable variable that can be used inside an atomic transaction.</p><h4 id=or-else-value><a href="#or-else-value"><code>(OR-ELSE TX-A TX-B)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L663-L682">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :A &rArr; (((<a href="#stm-type">STM</a> :A) :B) &rarr; ((<a href="#stm-type">STM</a> :A) :B) &rarr; ((<a href="#stm-type">STM</a> :A) :B))</code><p class=docstring>Run TX-A. If it signals a retry, run TX-b. If both transactions signal a
retry, then the entire transaction retries.</p><h4 id=run-tx-value><a href="#run-tx-value"><code>(RUN-TX TX)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L684-L711">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :B :C) (<a href="#monadexception-class">MonadException</a> :C) &rArr; (((<a href="#stm-type">STM</a> :C) :D) &rarr; (:C :D))</code><p class=docstring>Run an atomic transaction. If the transaction raises an exception, the transaction
is aborted and the exception is re-raised.

WARNING: The STM can abort and re-run the transaction repeatedly, until it completes with
a consistent snapshot of the data. Therefore, TX must be pure.</p><h4 id=retry-value><a href="#retry-value"><code>RETRY</code></a> <sup><sub>VALUE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/stm.lisp#L643-L660">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monadio-class">MonadIo</a> :A &rArr; ((<a href="#stm-type">STM</a> :A) :B)</code><p class=docstring>Retry the current operation because the observed state is invalid. Waits for a write
transaction to commit somewhere else, and then tries this transaction again.

This is useful if the transaction needs to wait for other threads to update the data
before it can continue. For example, if the transaction reads from a (TVar Queue) and the
queue is empty, it must wait until another thread pushes onto the queue before it can
continue.

Concurrent:
  - When the transaction runs, executing retry will abort the transaction and sleep the
    thread. The thread will sleep until any write transaction commits to the STM, when
    the retrying thread will wake and retry its transaction.
</p></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-gen-impl-conc-stm-do-run-tx-macro><a href="#io-gen-impl-conc-stm-do-run-tx-macro"><code>DO-RUN-TX (&amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><p class=docstring>Run an atomic transaction. If the transaction raises an exception, the transaction
is aborted and the exception is re-raised.

WARNING: The STM can abort and re-run the transaction repeatedly, until it completes with
a consistent snapshot of the data. Therefore, TX must be pure.</p></div>
      <hr><h1 id="io/conc/worker-pool-package">Package <code>IO/CONC/WORKER-POOL</code></h1><div class=structs-content>
       <h3 class=structs-header>Structs</h3><h4 id=workerpool-type><a href="#workerpool-type"><code>WorkerPool :A :B</code></a> <sup><sub>STRUCT · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L32-L36">src</a></sub></sup></sub></sup></h4><p class=docstring>A pool of worker threads that execute jobs submitted to the pool.</p><details>
        <summary>Instances</summary>
        <ul class=instances-list>
         <li class=instances-item><code><a href="#concurrent-class">Concurrent</a> (<a href="#concurrentgroup-type">ConcurrentGroup</a> :A <a href="#unit-type">Unit</a>) (<a href="#list-type">List</a> <a href="#unit-type">Unit</a>) &rArr; <a href="#concurrent-class">Concurrent</a> ((<a href="#workerpool-type">WorkerPool</a> :B) :A) <a href="#unit-type">Unit</a></code>
         <li class=instances-item><code><a href="#runtimerepr-class">RuntimeRepr</a> ((<a href="#workerpool-type">WorkerPool</a> :A) :B)</code></ul></details></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=request-shutdown-value><a href="#request-shutdown-value"><code>(REQUEST-SHUTDOWN POOL)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L85-L91">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :C :D) (<a href="#monadexception-class">MonadException</a> :D) &rArr; (((<a href="#workerpool-type">WorkerPool</a> :B) :C) &rarr; (:D <a href="#unit-type">Unit</a>))</code><p class=docstring>Request a shutdown. The threads in the pool will shutdown when all of the jobs already
in the queue are completed.

To immediately stop the threads, use `stop`.</p><h4 id=new-worker-pool-value><a href="#new-worker-pool-value"><code>(NEW-WORKER-POOL N-THREADS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L57-L70">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D. (<a href="#monadiothread-class">MonadIoThread</a> :A :D :B) (<a href="#unliftio-class">UnliftIo</a> :C :C) (<a href="#monadiothread-class">MonadIoThread</a> :A :D :C) (<a href="#monadexception-class">MonadException</a> :C) (<a href="#monadexception-class">MonadException</a> :B) (<a href="#concurrent-class">Concurrent</a> :D <a href="#unit-type">Unit</a>) (<a href="#liftio-class">LiftIo</a> :C :B) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:B ((<a href="#workerpool-type">WorkerPool</a> :C) :D)))</code><p class=docstring>Create a new worker pool. Automatically forks N-THREADS worker threads.</p><h4 id=submit-job-value><a href="#submit-job-value"><code>(SUBMIT-JOB POOL JOB)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/gen-impl/conc/worker-pool.lisp#L75-L81">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B :C :D :E. (<a href="#unliftio-class">UnliftIo</a> :D :B) (<a href="#liftto-class">LiftTo</a> :D :E) (<a href="#monadiothread-class">MonadIoThread</a> :A :C :B) (<a href="#monadexception-class">MonadException</a> :B) &rArr; (((<a href="#workerpool-type">WorkerPool</a> :B) :C) &rarr; (:D <a href="#unit-type">Unit</a>) &rarr; (:E <a href="#unit-type">Unit</a>))</code><p class=docstring>Submit a job to the worker pool. Any jobs submitted after a shutdown request will
be ignored.</p><h4 id=new-worker-pool_-value><a href="#new-worker-pool_-value"><code>(NEW-WORKER-POOL_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/worker-pool.lisp#L29-L29">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :A) (<a href="#monadexception-class">MonadException</a> :A) (<a href="#liftio-class">LiftIo</a> <a href="#io-type">IO</a> :A) &rArr; (<a href="#ufix-type">UFix</a> &rarr; (:A ((<a href="#workerpool-type">WorkerPool</a> <a href="#io-type">IO</a>) <a href="#iothread-type">IoThread</a>)))</code><h4 id=submit-job_-value><a href="#submit-job_-value"><code>(SUBMIT-JOB_)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/io-impl/conc/worker-pool.lisp#L34-L34">src</a></sub></sup></sub></sup></h4><code>&forall; :A. (<a href="#monadiothread-class">MonadIoThread</a> <a href="#ioruntime-type">IoRuntime</a> <a href="#iothread-type">IoThread</a> :A) (<a href="#liftto-class">LiftTo</a> <a href="#io-type">IO</a> :A) &rArr; (((<a href="#workerpool-type">WorkerPool</a> <a href="#io-type">IO</a>) <a href="#iothread-type">IoThread</a>) &rarr; (<a href="#io-type">IO</a> <a href="#unit-type">Unit</a>) &rarr; (:A <a href="#unit-type">Unit</a>))</code></div>
      <hr><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4
    id=io-io-impl-conc-worker-pool-do-submit-job_-macro><a href="#io-io-impl-conc-worker-pool-do-submit-job_-macro"><code>DO-SUBMIT-JOB_ (POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4><h4
    id=io-gen-impl-conc-worker-pool-do-submit-job-macro><a href="#io-gen-impl-conc-worker-pool-do-submit-job-macro"><code>DO-SUBMIT-JOB (POOL &amp;BODY BODY)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/io-all-package">Package <code>IO/IO-ALL</code></h1><div class=macros-content>
       <h3 class=macros-header>Macros</h3><h4 id=io-io-all-derive-monad-io-all-macro><a href="#io-io-all-derive-monad-io-all-macro"><code>DERIVE-MONAD-IO-ALL (MONAD-PARAM MONADT-FORM)</code></a> <sup><sub>MACRO</sub></sup></h4><h4 id=io-io-all-implement-monad-io-all-macro><a href="#io-io-all-implement-monad-io-all-macro"><code>IMPLEMENT-MONAD-IO-ALL (MONAD)</code></a> <sup><sub>MACRO</sub></sup></h4></div>
      <hr><h1 id="io/stubs/term-package">Package <code>IO/STUBS/TERM</code></h1><div class=types-content>
       <h3 class=types-header>Types</h3><h4 id=termstubm-type><a href="#termstubm-type"><code>TermStubM</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L46-L46">src</a></sub></sup></sub></sup></h4><h4 id=termstub-type><a href="#termstub-type"><code>TermStub</code></a> <sup><sub>TYPE · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L47-L47">src</a></sub></sup></sub></sup></h4></div>
      <hr><div class=values-content>
       <h3 class=values-header>Values</h3><h4 id=run-term-stubm-value><a href="#run-term-stubm-value"><code>(RUN-TERM-STUBM OPM READ-LINE-INPUTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L74-L113">src</a></sub></sup></sub></sup></h4><code>&forall; :A :B. <a href="#monad-class">Monad</a> :A &rArr; ((((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) :A) :B) &rarr; (<a href="#list-type">List</a> <a href="#string-type">String</a>) &rarr; (:A (<a href="#tuple-type">Tuple</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>) :B)))</code><h4 id=run-term-stub-value><a href="#run-term-stub-value"><code>(RUN-TERM-STUB STUB-OP READ-LINE-INPUTS)</code></a> <sup><sub>FUNCTION · <a href="https://github.com/Jason94/coalton-io/tree/master/src/stubs/term.lisp#L116-L117">src</a></sub></sup></sub></sup></h4><code>&forall; :A. ((((<a href="#freet-type">FreeT</a> <a href="#termstubf-type">TermStubF</a>) <a href="#identity-type">Identity</a>) :A) &rarr; (<a href="#list-type">List</a> <a href="#string-type">String</a>) &rarr; (<a href="#tuple-type">Tuple</a> (<a href="#list-type">List</a> <a href="#string-type">String</a>) :A))</code></div>
      <hr>
     </div>
    </div>
   </article>
  </main>
  <script>(function(){
  function text(el){return (el&&el.textContent||"").trim()}
  function buildIndex(main){
    var items=[]
    var pkg=""
    var walker=document.createTreeWalker(main,NodeFilter.SHOW_ELEMENT,null,false)
    var node=walker.currentNode
    while(node){
      var tag=node.tagName
      if(tag==="H1"){
        var code=node.querySelector("code")
        pkg=text(code)||text(node)
      }else if(tag==="H4"){
        var a=node.querySelector('a[href^="#"]')
        if(a){
          var href=a.getAttribute("href")||""
          var name=text(a)
          var sub=node.querySelector("sub")
          var typ=""
          if(sub){
            typ=text(sub).split("·")[0].trim()
          }
          if(href&&name){
            items.push({name:name,href:href,typ:typ,pkg:pkg})
          }
        }
      }
      node=walker.nextNode()
    }
    return items
  }
  function el(tag,cls,txt){
    var d=document.createElement(tag)
    if(cls)d.className=cls
    if(txt!=null)d.textContent=txt
    return d
  }
  function setup(){
    var input=document.getElementById("symbol-search-input")
    var results=document.getElementById("search-results")
    var main=document.querySelector(".main-content")
    if(!input||!results||!main)return
    var items=buildIndex(main)
    var activeIndex=-1
    function clear(){
      results.innerHTML=""
      results.classList.remove("active")
      activeIndex=-1
    }
    function setActive(i){
      var children=results.querySelectorAll(".search-result-item")
      for(var k=0;k<children.length;k++)children[k].classList.remove("active")
      if(i<0||i>=children.length)return
      children[i].classList.add("active")
      children[i].scrollIntoView({block:"nearest"})
    }
    function render(q){
      q=(q||"").trim().toLowerCase()
      results.innerHTML=""
      activeIndex=-1
      if(!q){
        results.classList.remove("active")
        return
      }
      var out=[]
      for(var i=0;i<items.length;i++){
        var it=items[i]
        if(it.name.toLowerCase().indexOf(q)!==-1){
          out.push(it)
          if(out.length>=40)break
        }
      }
      for(var j=0;j<out.length;j++){
        var it2=out[j]
        var row=el("div","search-result-item")
        row.tabIndex=-1
        row.dataset.href=it2.href
        row.appendChild(el("span","search-result-symbol",it2.name))
        if(it2.typ)row.appendChild(el("span","search-result-type",it2.typ))
        if(it2.pkg)row.appendChild(el("div","search-result-package",it2.pkg))
        row.addEventListener("mousedown",(function(href){
          return function(e){
            e.preventDefault()
            window.location.hash=href.slice(1)
            clear()
            input.blur()
          }
        })(it2.href))
        results.appendChild(row)
      }
      if(out.length)results.classList.add("active")
      else results.classList.remove("active")
    }
    input.addEventListener("input",function(){render(input.value)})
    input.addEventListener("focus",function(){if(input.value.trim())render(input.value)})
    input.addEventListener("keydown",function(e){
      var children=results.querySelectorAll(".search-result-item")
      if(e.key==="Escape"){
        clear()
        input.blur()
        return
      }
      if(!children.length)return
      if(e.key==="ArrowDown"){
        e.preventDefault()
        activeIndex=Math.min(children.length-1,activeIndex+1)
        setActive(activeIndex)
        results.classList.add("active")
        return
      }
      if(e.key==="ArrowUp"){
        e.preventDefault()
        activeIndex=Math.max(0,activeIndex-1)
        setActive(activeIndex)
        results.classList.add("active")
        return
      }
      if(e.key==="Enter"){
        if(activeIndex>=0&&activeIndex<children.length){
          var href=children[activeIndex].dataset.href
          if(href)window.location.hash=href.slice(1)
          clear()
          input.blur()
        }
      }
    })
    document.addEventListener("mousedown",function(e){
      if(e.target===input||results.contains(e.target))return
      clear()
    })
  }
  if(document.readyState==="loading")document.addEventListener("DOMContentLoaded",setup)
  else setup()
})();</script>
 </body>
</html>